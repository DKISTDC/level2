"""Exposes a URL that specifies the behavior of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behavior of this scalar."""
  url: String!
) on SCALAR

"""List of users who are exempt from embargo rules"""
type AuthorizedAgentResponse {
  """The primary key of the authorized agent"""
  authorizedAgentId: Int!

  """UUID for the identity record of the user in the Globus Auth platform"""
  userId: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input AuthorizedAgentsRequest {
  """The primary key of the authorized agent"""
  authorizedAgentId: Int

  """UUID for the identity record of the user in the Globus Auth platform"""
  userId: String
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values
"""
scalar BigInt

input CreateAuthorizedAgentRequest {
  """UUID for the identity record of the user in the Globus Auth platform"""
  userId: String!
}

input CreateDataAcquisitionSupportRecordRequest {
  """Id of the observing program execution that needs to be calibrated"""
  observingProgramExecutionId: String!

  """
  The maximum date of the data collected in an observing program to be used in calibration. (i.e. Observe and calibrate OPs)
  """
  dataAcquisitionCompletionDate: DateTime!

  """Id of the experiment the observing program belongs to"""
  experimentId: String!

  """Id of the proposal the observing program belongs to"""
  proposalId: String!

  """
  A list of observing program execution ids that are used to calibrate the processing candidate
  """
  calibratingObservingProgramExecutionIds: [String!] = null
}

input CreateDatasetCatalogReceiptAccountRequest {
  """The id of the dataset that receipts are being accounted for"""
  datasetId: String!

  """The number of receipts that are expected for the dataset"""
  expectedObjectCount: Int!
}

input CreateDatasetInventoryOverrideRequest {
  """The unique dataset id of the dataset being overridden"""
  datasetId: String!

  """Overridden dataset size"""
  datasetSize: Float = null

  """Overridden manually processed flag"""
  isManuallyProcessed: Boolean = null

  """Distribution of ATMOS_R0 among frames: {min, p25, med, p75, max}"""
  friedParameter: Distribution = null
}

input CreateDatasetInventoryRequest {
  """
  JSON String capturing all key value pairs for a dataset inventory record.
  """
  inventoryRecord: JSONString!
}

input CreateDatasetInventoryStatusRequest {
  """Status code of a dataset inventory record"""
  datasetInventoryStatusCode: String!

  """Short description of the status code"""
  datasetInventoryStatusDescription: String = null
}

input CreateDeadLetteredMessageRequest {
  """Properties from the dead lettered message"""
  properties: JSONString = null

  """The queue the message was dead lettered from"""
  queue: String = "UNKNOWN"

  """The payload of the dead lettered message"""
  payload: String = null

  """The conversation id from the  dead lettered message"""
  conversationId: String = null
}

input CreateDigestNotificationRequest {
  """Grouping type of notification"""
  notificationType: String!

  """The payload of the dead lettered message"""
  payload: JSONString = null

  """The conversation id from the message that caused the record insertion"""
  conversationId: String = null
}

input CreateExperimentDescriptionRequest {
  """Experiment Id to which the description belongs"""
  experimentId: String!

  """Description of the experiment"""
  experimentDescription: String = null
}

input CreateFrameInventoryRequest {
  """Bucket the object resides in"""
  bucket: String!

  """The key to access the object in the bucket"""
  objectKey: String!

  """JSON String capturing all the headers from the FITS file"""
  jsonFrameHeaders: String!

  """The FITS HDU the header is found within."""
  headerHdu: Int = 0
}

input CreateFrameReceiptExpectedRequest {
  """The number of frames expected to be received"""
  expectedFrameCount: Int!

  """The observing program execution the receipt accounts apply to"""
  observingProgramExecutionId: String!
}

input CreateFrameReceiptJournalRequest {
  """The observing program execution the receipt accounts apply to"""
  observingProgramExecutionId: String!

  """The number of frames to increase the expected count by"""
  expectedCountCredit: Int = null

  """The number of frames to decrease the expected count by"""
  expectedCountDebit: Int = null

  """The description of the journal entry"""
  description: String = null
}

input CreateGlobusTransferRequest {
  """Globally unique uuid for this task."""
  taskId: String!

  """Status of the task."""
  status: String!

  """User-defined label for the task."""
  label: String = null

  """The user ID of the task owner."""
  ownerId: String = null

  """The time the task was requested."""
  requestTime: DateTime = null

  """The time the task completed."""
  completionTime: DateTime = null

  """The source endpoint ID."""
  sourceEndpointId: String = null

  """The destination endpoint ID."""
  destinationEndpointId: String = null

  """The sync level of the task."""
  syncLevel: Int = null

  """Whether data encryption was enabled for the task."""
  encryptData: Boolean = null

  """Whether checksum verification was enabled for the task."""
  verifyChecksum: Boolean = null

  """Whether extra files at the destination were deleted."""
  deleteDestinationExtra: Boolean = null

  """Whether timestamps were preserved."""
  preserveTimestamp: Boolean = null

  """Whether source errors were skipped."""
  skipSourceErrors: Boolean = null

  """Whether the task failed on quota errors."""
  failOnQuotaErrors: Boolean = null

  """
  If the task was submitted via the CLI, this field will contain the original
  command line, including options, that created the task. If submitted via the
  Globus Web App or directly via the Transfer API, this will contain the string
  'API', followed by the API version, and optionally followed by a short string
  representing the client that submitted the request. The format of this field
  is subject to change and should not be relied upon.
  """
  command: String = null

  """Whether the task detail history was deleted."""
  historyDeleted: Boolean = null

  """The number of faults encountered during the task."""
  faults: BigInt = null

  """The total number of files in the task."""
  files: BigInt = null

  """The total number of directories in the task."""
  directories: BigInt = null

  """The number of files skipped during the task."""
  filesSkipped: BigInt = null

  """The number of files successfully transferred."""
  filesTransferred: BigInt = null

  """The total number of subtasks in the task."""
  subtasksTotal: BigInt = null

  """The number of subtasks that succeeded."""
  subtasksSucceeded: BigInt = null

  """The number of subtasks that failed."""
  subtasksFailed: BigInt = null

  """The number of subtasks that were canceled."""
  subtasksCanceled: BigInt = null

  """The number of subtasks that expired."""
  subtasksExpired: BigInt = null

  """The number of subtasks that were skipped due to errors."""
  subtasksSkippedErrors: BigInt = null

  """The total number of bytes transferred summed across all subtasks."""
  bytesTransferred: BigInt = null

  """Number of bytes checksummed when determining transfers (sync level 3)."""
  bytesChecksummed: BigInt = null

  """Bytes/second from start to completion/current time."""
  effectiveBytesPerSecond: BigInt = null

  """ID of the administrator who canceled the task."""
  canceledByAdmin: String = null

  """Message provided by the administrator on cancellation."""
  canceledByAdminMessage: String = null

  """The local user on the source endpoint."""
  sourceLocalUser: String = null

  """The local user on the destination endpoint."""
  destinationLocalUser: String = null

  """
  If store_base_path_info was set to true when task was submitted, the parent
  directory of the source_path (transfer) or path (delete) field for the first
  item listed in the task. Is null otherwise.
  """
  sourceBasePath: String = null

  """
  If store_base_path_info was set to true when a transfer task was submitted,
  the parent directory of the destination_path field for the first item listed
  in the task. Is null otherwise.
  """
  destinationBasePath: String = null

  """Parent paths from source paths in transfer details."""
  sourcePathParents: [String!] = null

  """Parent paths from destination paths in transfer details."""
  destinationPathParents: [String!] = null
}

input CreateInputDatasetInputDatasetPartRequest {
  """Foreign key to the input dataset"""
  inputDatasetId: Int!

  """Foreign key to the input dataset part"""
  inputDatasetPartId: Int!
}

input CreateInputDatasetPartRequest {
  """
  JSON document containing the list of frame_ids, object_ids, parameters, and parameter_values necessary for data processing
  """
  inputDatasetPartDocument: JSONString!

  """Foreign key to the input dataset part type table"""
  inputDatasetPartTypeId: Int!
}

input CreateInputDatasetPartTypeRequest {
  """Unique name for the input dataset part type"""
  inputDatasetPartTypeName: String!

  """Description of the input dataset part type"""
  inputDatasetPartTypeDescription: String = null
}

input CreateInputDatasetRequest {
  """
  A boolean value indicating whether the input dataset has been used and therefor cannot be updated
  """
  isActive: Boolean!
}

input CreateInstrumentRequest {
  """Name of the instrument"""
  instrumentName: String!
}

input CreateObjectInventoryRequest {
  """Bucket the object resides in"""
  bucket: String!

  """The key to access the object in the bucket"""
  objectKey: String!

  """
  The type of object being inventoried. e.g. ASDF, MOVIE, QREPORT, QDATA, PARAMETER_VALUE or WFC
  """
  objectType: String!

  """
  The id for the group to which the object belongs e.g. datasetId for ASDF, movie, and Quality Report.
  """
  groupId: String

  """
  The name of the group to which the object belongs. e.g. DATASET, OPEXEC, or PARAMETER_VALUE
  """
  groupName: String
}

input CreateParameterRequest {
  """Name of the parameter"""
  parameterName: String!

  """Foreign key to the parameter type"""
  parameterTypeId: Int!

  """Description of the parameter"""
  parameterDescription: String = null
}

input CreateParameterTypeRequest {
  """Name of the parameter type"""
  parameterTypeName: String!

  """Description of the parameter type"""
  parameterTypeDescription: String = null
}

input CreateParameterValueRequest {
  """Foreign key to the parameter"""
  parameterId: Int!

  """A JSON structured value of the parameter."""
  parameterValue: JSONString!

  """Date and time the value became effective. Used for validity"""
  parameterValueStartDate: DateTime = null

  """A JSON structured documentation of the provenance of a parameter value"""
  parameterValueProvenance: JSONString = null
}

input CreateProcessingCampaignRequest {
  """The unique name for the processing campaign"""
  processingCampaignName: String!

  """Short description of the processing campaign"""
  processingCampaignDescription: String = null

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  plannedRecipeCount: Int = null
}

input CreateProcessingCandidateCalibrationRequest {
  """Foreign key to the processing candidate"""
  processingCandidateId: Int!

  """
  Id of the observing program execution that will be used to calibrate the candidate
  """
  observingProgramExecutionId: String!
}

input CreateProcessingCandidateRequest {
  """Id of the observing program execution that needs to be calibrated"""
  observingProgramExecutionId: String!

  """
  The maximum date of the data collected in an observing program to be used in calibration. (i.e. Observe and calibrate OPs)
  """
  dataAcquisitionCompletionDate: DateTime!

  """Id of the experiment the observing program belongs to"""
  experimentId: String!

  """Id of the proposal the observing program belongs to"""
  proposalId: String!

  """Locking status of the processing candidate. """
  isLocked: Boolean!

  """
  The number of recipe instances expected.  Used to determine if a processing candidate is complete
  """
  plannedRecipeCount: Int = null
}

input CreateProposalAccessRequest {
  """The proposal the access record applies to"""
  proposalId: String!

  """The duration of the embargo with 0 meaning no embargo at all"""
  embargoDuration: Int!

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean!

  """List of the globus user ids for the investigators on a proposal"""
  userIds: [String!] = null
}

input CreateProposalInvestigatorRequest {
  """Foreign key to the proposal access table"""
  proposalAccessId: Int!

  """UUID for the identity record of the user in the Globus Auth platform"""
  userId: String!
}

input CreateRecipeConfigurationRequest {
  """
  Name of the recipe configuration used to distinguish configuration sets
  """
  recipeConfigurationName: String!

  """Description of the recipe configuration"""
  recipeConfigurationDescription: String = null

  """
  A JSON structured enumeration of the default configuration available for recipes
  """
  recipeConfiguration: JSONString = null
}

input CreateRecipeInstanceRequest {
  """Foreign key to the related recipe"""
  recipeId: Int!

  """
  Foreign key to the present (for the one used on a dataset see
  recipeRunProvenance) input dataset used in the instance definition
  """
  inputDatasetId: Int!

  """Foreign key to the related processing candidate"""
  processingCandidateId: Int = null

  """Foreign key to the related processing campaign"""
  processingCampaignId: Int = null
}

input CreateRecipeInstrumentRequest {
  """Foreign key to instrument"""
  instrumentId: Int!

  """Foreign key to recipe"""
  recipeId: Int!
}

input CreateRecipeParameterRequest {
  """Foreign key to recipe"""
  recipeId: Int!

  """Foreign key to the parameter"""
  parameterId: Int!
}

input CreateRecipeRequest {
  """Name describing the recipe"""
  recipeName: String!

  """
  Flag indicating whether the recipe will be scheduled for automatic processing or manual processing
  """
  isAutoProcessed: Boolean! = true

  """Longer description of the recipe"""
  recipeDescription: String = null

  """Flag indicating whether the recipe is active"""
  isActive: Boolean! = false

  """
  Name of the resource pool which can be used as a parameter for automated processing
  """
  resourcePool: String = null

  """Foreign key to the workflow associated with the recipe"""
  workflowId: Int = null

  """Unique id of the recipe configuration record"""
  recipeConfigurationId: Int = null
}

input CreateRecipeRunProvenanceRequest {
  """version of the code executed in a recipe run task"""
  codeVersion: String = null

  """version of the workflow the recipe run used"""
  workflowVersion: String = null

  """
  versions of the critical (as determined by the code) libraries used by the recipe run task
  """
  libraryVersions: String = null

  """Workflow task the provenance record applies to"""
  taskName: String = null

  """
  Foreign key to the recipe run the provenance record applies to.  Also used to find frames the provenance record applies to
  """
  recipeRunId: Int!

  """Flag indicating whether the tag was manually intervened with"""
  isTaskManual: Boolean!

  """Foreign key to the input dataset that was used in the recipe run"""
  inputDatasetId: Int!
}

input CreateRecipeRunRequest {
  """Foreign Key to the recipe instance"""
  recipeInstanceId: Int!

  """
  Priority of the recipe run that is passed to the automated processing
  scheduler as a parameter for scheduling where a higher number equals a higher priority
  """
  priority: Int = null

  """Foreign Key to the recipe run status"""
  recipeRunStatusId: Int!

  """
  The id of the airflow run used to discover the recipe run in the case of DAG failure
  """
  dagRunId: String = null

  """A JSON structured enumeration of the configuration for the recipe run"""
  configuration: JSONString = null
}

input CreateRecipeRunStatusRequest {
  """Name of the status"""
  recipeRunStatusName: String!

  """
  Description of the status, ideally including inbound and outbound transitions
  """
  recipeRunStatusDescription: String = null

  """
  A boolean indicator of whether a status can be interpreted as complete i.e. there is no work left to be done
  """
  isComplete: Boolean!
}

input CreateWorkflowRequest {
  """
  Name of the workflow which corresponds to the DAG name known to the scheduler
  """
  workflowName: String!

  """Description of the workflow"""
  workflowDescription: String = null
}

input DatasetCatalogReceiptAccountRequest {
  """Unique id for the dataset catalog receipt account"""
  datasetCatalogReceiptAccountId: Int

  """The id of the dataset that receipts are being accounted for"""
  datasetId: String

  """A flag indicating whether the dataset is locked for processing"""
  isLocked: Boolean

  """
  Boolean indicating true if all objects that are expected have not yet been received
  """
  isReceivedCountLessThanExpected: Boolean
}

"""
Aggregation table for expected and actual processed object receipts grouped by dataset id
"""
type DatasetCatalogReceiptAccountResponse {
  """Unique id for the dataset catalog receipt account"""
  datasetCatalogReceiptAccountId: Int!

  """The id of the dataset that receipts are being accounted for"""
  datasetId: String!

  """The number of receipts that are expected for the dataset"""
  expectedObjectCount: Int!

  """The number of receipts that have been received for the dataset"""
  receivedObjectCount: Int!

  """A flag indicating whether the dataset is locked for processing"""
  isLocked: Boolean

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input DatasetInventoriesRequest {
  """
  The number of rows to return in a single call. Default is all records on 1 page.
  """
  pageSize: Int = null

  """
  The page number to return. e.g. 1 is the first page and 10 the 10th. Default is page 1
  """
  pageNumber: Int = 1

  """
  A column to order by the input dataset part results by e.g createDate to order
  by create date ascending or -updateDate to order by update date descending.
  """
  sortColumn: String = "createDate"

  """
  The object key used to retrieve the asdf file from the same bucket as the frame objects
  """
  asdfObjectKey: String

  """
  Minimum value for 'The average spectral sampling size if it exists (nm)'
  """
  averageDatasetSpectralSamplingMin: Float

  """
  Maximum value for 'The average spectral sampling size if it exists (nm)'
  """
  averageDatasetSpectralSamplingMax: Float

  """Minimum value for 'The average spatial sampling size if it exists'"""
  averageDatasetSpatialSamplingMin: Float

  """Maximum value for 'The average spatial sampling size if it exists'"""
  averageDatasetSpatialSamplingMax: Float

  """Minimum value for 'The average temporal sampling size if it exists'"""
  averageDatasetTemporalSamplingMin: Float

  """Maximum value for 'The average temporal sampling size if it exists'"""
  averageDatasetTemporalSamplingMax: Float

  """
  The object key used to retrieve the browse movie from the browse-movie bucket
  """
  browseMovieObjectKey: String

  """The URL for the published browse movie in Vimeo"""
  browseMovieUrl: String

  """The bucket the frame objects and asdf file reside in"""
  bucket: String

  """Earliest date for 'Date time in UTC the record was created'"""
  createDateMin: DateTime

  """Latest date for 'Date time in UTC the record was created'"""
  createDateMax: DateTime

  """
  A list of product ids (string).  Elements: 'A key that does not change upon
  reprocessing which allows datasets to be grouped based on their input observe data'
  """
  productIds: [String!]

  """
  A list of dataset ids (string).  Elements: 'The unique id of the dataset'
  """
  datasetIds: [String!]

  """The unique id of the dataset inventory record"""
  datasetInventoryId: Int

  """Earliest date for 'Date an embargoed proposal will become unembargoed'"""
  embargoEndDateMin: DateTime

  """Latest date for 'Date an embargoed proposal will become unembargoed'"""
  embargoEndDateMax: DateTime

  """
  Earliest date for 'Time of acquisition for the latest frame in the data set'
  """
  endTimeMin: DateTime

  """
  Latest date for 'Time of acquisition for the latest frame in the data set'
  """
  endTimeMax: DateTime

  """
  Earliest date for 'Time of acquisition for the latest frame in the data set'
  """
  execTimeMin: DateTime

  """
  Latest date for 'Time of acquisition for the earliest frame in the data set'
  """
  execTimeMax: DateTime

  """
  Minimum value for 'The mode length of time that the CCD was exposed for within the dataset'
  """
  exposureTimeMin: Float

  """
  Maximum value for 'The mode length of time that the CCD was exposed for within the dataset'
  """
  exposureTimeMax: Float

  """
  A Boolean indicating true if all stokes parameters exist in the data set
  """
  hasAllStokes: Boolean

  """Flag indicating that the dataset contains a spectral axis"""
  hasSpectralAxis: Boolean

  """Flag indicating that the dataset contains a time axis"""
  hasTemporalAxis: Boolean

  """
  A flag that indicates if the generation of this dataset required manual processing
  """
  isManuallyProcessed: Boolean

  """Earliest date for 'Date the data was processed'"""
  headerDataUnitCreationDateMin: DateTime

  """Latest date for 'Date the data was processed'"""
  headerDataUnitCreationDateMax: DateTime

  """
  Version of the header specification (spec 214) used to package the data
  """
  headerVersion: String

  """
  Version of the High Level Software (HLS) used on the summit at the time of data acquisition
  """
  highLevelSoftwareVersion: String

  """Id of the parameters section of the input dataset"""
  inputDatasetParametersPartId: Int

  """Id of the observe frames section of the input dataset"""
  inputDatasetObserveFramesPartId: Int

  """Id of the calibration frames section of the input dataset"""
  inputDatasetCalibrationFramesPartId: Int

  """
  A list of instrument names (string).  Elements: 'Name of the instrument that produced the data in the dataset'
  """
  instrumentNames: [String!]

  """The instrument program execution id the data was collected using"""
  instrumentProgramExecutionId: String

  """
  A list of user ids (string).  Elements: 'UUID for the identity record of the user in the Globus Auth platform'
  """
  investigatorUserIds: [String!]

  """Status of the dataset inventory record"""
  status: String

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean

  """The observing program execution id the data was collected using"""
  observingProgramExecutionId: String

  """
  A list of experiment ids (string).  Elements: 'The experiment id the observation data was collected under'
  """
  primaryExperimentIds: [String!]

  """
  A list of proposal ids (string).  Elements: 'The proposal id the observation data was collected under'
  """
  primaryProposalIds: [String!]

  """Minimum value for 'Average Fried parameter in the dataset'"""
  qualityAverageFriedParameterMin: Float

  """Maximum value for 'Average Fried parameter in the dataset'"""
  qualityAverageFriedParameterMax: Float

  """
  Minimum value for 'Average polarimetric accuracy calculated from the dataset'
  """
  qualityAveragePolarimetricAccuracyMin: Float

  """
  Maximum value for 'Average polarimetric accuracy calculated from the dataset'
  """
  qualityAveragePolarimetricAccuracyMax: Float

  """
  The object key used to retrieve the quality report file from the same bucket as the frame objects
  """
  qualityReportObjectKey: String

  """
  The object key used to retrieve the quality data file from the same bucket as the frame objects
  """
  qualityDataObjectKey: String

  """
  Foreign key reference to the recipe specification that created the data set
  """
  recipeId: Int

  """Foreign key reference to the recipe instance that created the data set"""
  recipeInstanceId: Int

  """
  Foreign key reference to the recipe run that created the data set.  Also used to look up provenance information
  """
  recipeRunId: Int

  """
  Containing 'The spatial extent of all data within the dataset in arc seconds
  from the center of the sun using the upper right and lower left corners in
  that order and in the format ((x1,y1),(x2,y2))'
  """
  rectangleContainingBoundingBox: String

  """
  Contained by 'The spatial extent of all data within the dataset in arc seconds
  from the center of the sun using the upper right and lower left corners in
  that order and in the format ((x1,y1),(x2,y2))'
  """
  rectangleContainedByBoundingBox: String

  """
  Intersecting 'The spatial extent of all data within the dataset in arc seconds
  from the center of the sun using the upper right and lower left corners in
  that order and in the format ((x1,y1),(x2,y2))'
  """
  rectangleIntersectingBoundingBox: String

  """
  Earliest date for 'Time of acquisition for the earliest frame in the data set'
  """
  startTimeMin: DateTime

  """
  Latest date for 'Time of acquisition for the earliest frame in the data set'
  """
  startTimeMax: DateTime

  """
  A list of target types (string).  Elements: 'Contains the value of the OBJECT
  field in the input frames of the processing candidate'
  """
  targetTypes: [String!]

  """Earliest date for 'Date time in UTC the record was last updated'"""
  updateDateMin: DateTime

  """Latest date for 'Date time in UTC the record was last updated'"""
  updateDateMax: DateTime

  """A list of wavelength ranges (float)."""
  wavelengthRanges: [Float!]

  """Name of the workflow used to process the data"""
  workflowName: String

  """Version of the workflow used to process the data"""
  workflowVersion: String

  """
  A list of named spectral lines (string).  Elements: 'A list of named spectral lines within a dataset'
  """
  spectralLines: [String!]
}

input DatasetInventoryHistory {
  """The unique id of the dataset"""
  datasetId: String

  """
  A key that does not change upon reprocessing which allows datasets to be grouped based on their input observe data
  """
  productId: String

  """
  The number of rows to return in a single call. Default is all records on 1 page.
  """
  pageSize: Int = null

  """
  The page number to return. e.g. 1 is the first page and 10 the 10th. Default is page 1
  """
  pageNumber: Int = 1

  """
  A column to order by the input dataset part results by.The default of `-createDate` orders by create date descending.
  """
  sortColumn: String = "-createDate"
}

input DatasetInventoryHistoryRecordCountRequest {
  """The unique id of the dataset"""
  datasetId: String

  """
  A key that does not change upon reprocessing which allows datasets to be grouped based on their input observe data
  """
  productId: String

  """Page size is ignored when determining Dataset Inventory Record Counts."""
  pageSize: Int = null

  """
  Page number is ignored when determining Dataset Inventory Record Counts.
  """
  pageNumber: Int = 1

  """
  Sort column is ignored when determining Dataset Inventory Record Counts.
  """
  sortColumn: String = "-createDate"
}

"""Values and ranges for data in dataset inventory"""
type DatasetInventoryLookupResponse {
  """Name of the field the lookup applies to"""
  fieldName: String!

  """A list of unique values found for the database column"""
  categoricalValues: [String!]

  """Minimum value found for the database column"""
  minValue: String

  """Maximum value found for the database column"""
  maxValue: String

  """Data type of the value. Options defined by DataType type"""
  dataType: DataType
}

"""A list of overridden dataset inventory records"""
type DatasetInventoryOverrideResponse {
  """Primary key for the dataset inventory override table"""
  datasetInventoryOverrideId: Int!

  """The unique dataset id of the dataset being overridden"""
  datasetId: String!

  """Overridden dataset size"""
  datasetSize: Float

  """Overridden manually processed flag"""
  isManuallyProcessed: Boolean

  """Overridden fried parameter"""
  friedParameter: Distribution

  """Date the override record was created"""
  createDate: DateTime!

  """Date the override record was last updated"""
  updateDate: DateTime
}

input DatasetInventoryOverridesRequest {
  """Primary key for the dataset inventory override table"""
  datasetInventoryOverrideId: Int

  """The unique dataset id of the dataset being overridden"""
  datasetId: String
}

input DatasetInventoryRecordCountRequest {
  """Page size is ignored when determining Dataset Inventory Record Counts."""
  pageSize: Int = null

  """
  Page number is ignored when determining Dataset Inventory Record Counts.
  """
  pageNumber: Int = 1

  """
  Sort column is ignored when determining Dataset Inventory Record Counts.
  """
  sortColumn: String = "createDate"

  """
  The object key used to retrieve the asdf file from the same bucket as the frame objects
  """
  asdfObjectKey: String

  """
  Minimum value for 'The average spectral sampling size if it exists (nm)'
  """
  averageDatasetSpectralSamplingMin: Float

  """
  Maximum value for 'The average spectral sampling size if it exists (nm)'
  """
  averageDatasetSpectralSamplingMax: Float

  """Minimum value for 'The average spatial sampling size if it exists'"""
  averageDatasetSpatialSamplingMin: Float

  """Maximum value for 'The average spatial sampling size if it exists'"""
  averageDatasetSpatialSamplingMax: Float

  """Minimum value for 'The average temporal sampling size if it exists'"""
  averageDatasetTemporalSamplingMin: Float

  """Maximum value for 'The average temporal sampling size if it exists'"""
  averageDatasetTemporalSamplingMax: Float

  """
  The object key used to retrieve the browse movie from the browse-movie bucket
  """
  browseMovieObjectKey: String

  """The URL for the published browse movie in Vimeo"""
  browseMovieUrl: String

  """The bucket the frame objects and asdf file reside in"""
  bucket: String

  """Earliest date for 'Date time in UTC the record was created'"""
  createDateMin: DateTime

  """Latest date for 'Date time in UTC the record was created'"""
  createDateMax: DateTime

  """
  A list of product ids (string).  Elements: 'A key that does not change upon
  reprocessing which allows datasets to be grouped based on their input observe data'
  """
  productIds: [String!]

  """
  A list of dataset ids (string).  Elements: 'The unique id of the dataset'
  """
  datasetIds: [String!]

  """The unique id of the dataset inventory record"""
  datasetInventoryId: Int

  """Earliest date for 'Date an embargoed proposal will become unembargoed'"""
  embargoEndDateMin: DateTime

  """Latest date for 'Date an embargoed proposal will become unembargoed'"""
  embargoEndDateMax: DateTime

  """
  Earliest date for 'Time of acquisition for the latest frame in the data set'
  """
  endTimeMin: DateTime

  """
  Latest date for 'Time of acquisition for the latest frame in the data set'
  """
  endTimeMax: DateTime

  """
  Earliest date for 'Time of acquisition for the latest frame in the data set'
  """
  execTimeMin: DateTime

  """
  Latest date for 'Time of acquisition for the earliest frame in the data set'
  """
  execTimeMax: DateTime

  """
  Minimum value for 'The mode length of time that the CCD was exposed for within the dataset'
  """
  exposureTimeMin: Float

  """
  Maximum value for 'The mode length of time that the CCD was exposed for within the dataset'
  """
  exposureTimeMax: Float

  """
  A Boolean indicating true if all stokes parameters exist in the data set
  """
  hasAllStokes: Boolean

  """Flag indicating that the dataset contains a spectral axis"""
  hasSpectralAxis: Boolean

  """Flag indicating that the dataset contains a time axis"""
  hasTemporalAxis: Boolean

  """
  A flag that indicates if the generation of this dataset required manual processing
  """
  isManuallyProcessed: Boolean

  """Earliest date for 'Date the data was processed'"""
  headerDataUnitCreationDateMin: DateTime

  """Latest date for 'Date the data was processed'"""
  headerDataUnitCreationDateMax: DateTime

  """
  Version of the header specification (spec 214) used to package the data
  """
  headerVersion: String

  """
  Version of the High Level Software (HLS) used on the summit at the time of data acquisition
  """
  highLevelSoftwareVersion: String

  """Id of the parameters section of the input dataset"""
  inputDatasetParametersPartId: Int

  """Id of the observe frames section of the input dataset"""
  inputDatasetObserveFramesPartId: Int

  """Id of the calibration frames section of the input dataset"""
  inputDatasetCalibrationFramesPartId: Int

  """
  A list of instrument names (string).  Elements: 'Name of the instrument that produced the data in the dataset'
  """
  instrumentNames: [String!]

  """The instrument program execution id the data was collected using"""
  instrumentProgramExecutionId: String

  """
  A list of user ids (string).  Elements: 'UUID for the identity record of the user in the Globus Auth platform'
  """
  investigatorUserIds: [String!]

  """Status of the dataset inventory record"""
  status: String

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean

  """The observing program execution id the data was collected using"""
  observingProgramExecutionId: String

  """
  A list of experiment ids (string).  Elements: 'The experiment id the observation data was collected under'
  """
  primaryExperimentIds: [String!]

  """
  A list of proposal ids (string).  Elements: 'The proposal id the observation data was collected under'
  """
  primaryProposalIds: [String!]

  """Minimum value for 'Average Fried parameter in the dataset'"""
  qualityAverageFriedParameterMin: Float

  """Maximum value for 'Average Fried parameter in the dataset'"""
  qualityAverageFriedParameterMax: Float

  """
  Minimum value for 'Average polarimetric accuracy calculated from the dataset'
  """
  qualityAveragePolarimetricAccuracyMin: Float

  """
  Maximum value for 'Average polarimetric accuracy calculated from the dataset'
  """
  qualityAveragePolarimetricAccuracyMax: Float

  """
  The object key used to retrieve the quality report file from the same bucket as the frame objects
  """
  qualityReportObjectKey: String

  """
  The object key used to retrieve the quality data file from the same bucket as the frame objects
  """
  qualityDataObjectKey: String

  """
  Foreign key reference to the recipe specification that created the data set
  """
  recipeId: Int

  """Foreign key reference to the recipe instance that created the data set"""
  recipeInstanceId: Int

  """
  Foreign key reference to the recipe run that created the data set.  Also used to look up provenance information
  """
  recipeRunId: Int

  """
  Containing 'The spatial extent of all data within the dataset in arc seconds
  from the center of the sun using the upper right and lower left corners in
  that order and in the format ((x1,y1),(x2,y2))'
  """
  rectangleContainingBoundingBox: String

  """
  Contained by 'The spatial extent of all data within the dataset in arc seconds
  from the center of the sun using the upper right and lower left corners in
  that order and in the format ((x1,y1),(x2,y2))'
  """
  rectangleContainedByBoundingBox: String

  """
  Intersecting 'The spatial extent of all data within the dataset in arc seconds
  from the center of the sun using the upper right and lower left corners in
  that order and in the format ((x1,y1),(x2,y2))'
  """
  rectangleIntersectingBoundingBox: String

  """
  Earliest date for 'Time of acquisition for the earliest frame in the data set'
  """
  startTimeMin: DateTime

  """
  Latest date for 'Time of acquisition for the earliest frame in the data set'
  """
  startTimeMax: DateTime

  """
  A list of target types (string).  Elements: 'Contains the value of the OBJECT
  field in the input frames of the processing candidate'
  """
  targetTypes: [String!]

  """Earliest date for 'Date time in UTC the record was last updated'"""
  updateDateMin: DateTime

  """Latest date for 'Date time in UTC the record was last updated'"""
  updateDateMax: DateTime

  """A list of wavelength ranges (float)."""
  wavelengthRanges: [Float!]

  """Name of the workflow used to process the data"""
  workflowName: String

  """Version of the workflow used to process the data"""
  workflowVersion: String

  """
  A list of named spectral lines (string).  Elements: 'A list of named spectral lines within a dataset'
  """
  spectralLines: [String!]
}

"""Number of dataset inventory records matching a query"""
type DatasetInventoryRecordCountResponse {
  """Number of records matching a query"""
  recordCount: Int!
}

"""Metadata for the discovery of datasets"""
type DatasetInventoryResponse {
  """The unique id of the dataset inventory record"""
  datasetInventoryId: Int!

  """
  The object key used to retrieve the asdf file from the same bucket as the frame objects
  """
  asdfObjectKey: String

  """
  The spatial extent of all data within the dataset in arc seconds from the
  center of the sun using the upper right and lower left corners in that order
  and in the format ((x1,y1),(x2,y2))
  """
  boundingBox: String

  """
  The object key used to retrieve the browse movie from the browse-movie bucket
  """
  browseMovieObjectKey: String

  """The URL for the published browse movie in Vimeo"""
  browseMovieUrl: String

  """
  A key that does not change upon reprocessing which allows datasets to be grouped based on their input observe data
  """
  productId: String!

  """The unique id of the dataset"""
  datasetId: String!

  """
  A sum of the size in GB (space on disk) of the available frames within a data set in
  """
  datasetSize: Float

  """Time of acquisition for the latest frame in the data set"""
  endTime: DateTime

  """A list of the experiment ids that contributed to a dataset"""
  contributingExperimentIds: [String!]!

  """
  The mode length of time that the CCD was exposed for within the dataset
  """
  exposureTime: Float

  """Number of frames currently available within a data set"""
  frameCount: Int!

  """Name of the instrument that produced the data in the dataset"""
  instrumentName: String

  """Number of frames in the data set when it was created"""
  originalFrameCount: Int!

  """The experiment id the observation data was collected under"""
  primaryExperimentId: String

  """The proposal id the observation data was collected under"""
  primaryProposalId: String!

  """A list of the proposal ids that contributed to a dataset"""
  contributingProposalIds: [String!]!

  """Average Fried parameter in the dataset"""
  qualityAverageFriedParameter: Float

  """Average polarimetric accuracy calculated from the dataset"""
  qualityAveragePolarimetricAccuracy: Float

  """Foreign key reference to the recipe instance that created the data set"""
  recipeInstanceId: Int!

  """
  Foreign key reference to the recipe run that created the data set.  Also used to look up provenance information
  """
  recipeRunId: Int!

  """
  Foreign key reference to the recipe specification that created the data set
  """
  recipeId: Int!

  """Time of acquisition for the earliest frame in the data set"""
  startTime: DateTime

  """
  A Boolean indicating true if all stokes parameters exist in the data set
  """
  hasAllStokes: Boolean

  """A list of which stokes parameters exist in the dataset (I, Q, U, V)"""
  stokesParameters: String

  """
  Contains the value of the OBJECT field in the input frames of the processing candidate
  """
  targetTypes: [String!]!

  """Upper bound of wavelength range within a dataset"""
  wavelengthMax: Float

  """Lower bound of wavelength range within a dataset"""
  wavelengthMin: Float

  """The bucket the frame objects and asdf file reside in"""
  bucket: String!

  """Status of the dataset inventory record"""
  status: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """Flag indicating that the dataset contains a spectral axis"""
  hasSpectralAxis: Boolean

  """Flag indicating that the dataset contains a time axis"""
  hasTemporalAxis: Boolean

  """
  A flag that indicates if the generation of this dataset required manual processing
  """
  isManuallyProcessed: Boolean

  """The average spectral sampling size if it exists (nm)"""
  averageDatasetSpectralSampling: Float

  """The average spatial sampling size if it exists"""
  averageDatasetSpatialSampling: Float

  """The average temporal sampling size if it exists"""
  averageDatasetTemporalSampling: Float

  """
  JSON document containing any extra key value pairs provided on the creation of an inventory record
  """
  extraInventory: JSON

  """
  The object key used to retrieve the quality report file from the same bucket as the frame objects
  """
  qualityReportObjectKey: String

  """
  The object key used to retrieve the quality data file from the same bucket as the frame objects
  """
  qualityDataObjectKey: String

  """Id of the parameters section of the input dataset"""
  inputDatasetParametersPartId: Int

  """Id of the observe frames section of the input dataset"""
  inputDatasetObserveFramesPartId: Int

  """Id of the calibration frames section of the input dataset"""
  inputDatasetCalibrationFramesPartId: Int

  """
  Version of the High Level Software (HLS) used on the summit at the time of data acquisition
  """
  highLevelSoftwareVersion: String

  """Name of the workflow used to process the data"""
  workflowName: String

  """Version of the workflow used to process the data"""
  workflowVersion: String

  """Date the data was processed"""
  headerDataUnitCreationDate: DateTime

  """The observing program execution id the data was collected using"""
  observingProgramExecutionId: String

  """The instrument program execution id the data was collected using"""
  instrumentProgramExecutionId: String

  """
  Version of the header specification (spec 214) used to package the data
  """
  headerVersion: String

  """
  Link to the documentation for the version of the header specification (spec 214) used to package the data
  """
  headerDocumentationUrl: String

  """Link to additional documentation for the dataset"""
  infoUrl: String

  """
  Link to the documentation for the version of the workflow used to process the data
  """
  calibrationDocumentationUrl: String

  """Counts of frame HEALTH values. {GOOD: 32, BAD, ILL, UNKNOWN}"""
  health: HealthCounts

  """
  Counts of frame GOS_STATUS values. {open: 32, opening, closed, closing, undefined}
  """
  gosStatus: GosStatusCounts

  """Count of frames with AO_LOCK=true"""
  aoLocked: Int

  """Distribution of LIGHTLVL among frames: {min, p25, med, p75, max}"""
  lightLevel: DistributionString

  """Distribution of POL_SENS among frames: {min, p25, med, p75, max}"""
  polarimetricAccuracy: DistributionString

  """Distribution of ATMOS_R0 among frames: {min, p25, med, p75, max}"""
  friedParameter: DistributionString

  """A list of named spectral lines within a dataset"""
  spectralLines: [String!]
}

input DatasetInventoryStatusesRequest {
  """Primary key for the dataset inventory status table"""
  datasetInventoryStatusId: Int

  """Status code of a dataset inventory record"""
  datasetInventoryStatusCode: String
}

"""A list of the valid status codes for dataset inventory records"""
type DatasetInventoryStatusResponse {
  """Primary key for the dataset inventory status table"""
  datasetInventoryStatusId: Int!

  """Status code of a dataset inventory record"""
  datasetInventoryStatusCode: String!

  """Short description of the status code"""
  datasetInventoryStatusDescription: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of dataset inventories with this status."""
  datasetInventories: [DatasetInventoryViewResponse!]
}

"""
Metadata for the discovery of datasets with the addition of embargo, experiment description, and investigators
"""
type DatasetInventoryViewResponse {
  """The unique id of the dataset inventory record"""
  datasetInventoryId: Int!

  """
  The object key used to retrieve the asdf file from the same bucket as the frame objects
  """
  asdfObjectKey: String

  """
  The spatial extent of all data within the dataset in arc seconds from the
  center of the sun using the upper right and lower left corners in that order
  and in the format ((x1,y1),(x2,y2))
  """
  boundingBox: String

  """
  The object key used to retrieve the browse movie from the browse-movie bucket
  """
  browseMovieObjectKey: String

  """The URL for the published browse movie in Vimeo"""
  browseMovieUrl: String

  """The bucket the frame objects and asdf file reside in"""
  bucket: String!

  """
  A key that does not change upon reprocessing which allows datasets to be grouped based on their input observe data
  """
  productId: String!

  """The unique id of the dataset"""
  datasetId: String!

  """
  A sum of the size in GB (space on disk) of the available frames within a data set in
  """
  datasetSize: Float

  """Time of acquisition for the latest frame in the data set"""
  endTime: DateTime

  """A list of the experiment ids that contributed to a dataset"""
  contributingExperimentIds: [String!]!

  """
  The mode length of time that the CCD was exposed for within the dataset
  """
  exposureTime: Float

  """Number of frames currently available within a data set"""
  frameCount: Int!

  """Name of the instrument that produced the data in the dataset"""
  instrumentName: String

  """Number of frames in the data set when it was created"""
  originalFrameCount: Int!

  """The experiment id the observation data was collected under"""
  primaryExperimentId: String

  """The proposal id the observation data was collected under"""
  primaryProposalId: String!

  """A list of the proposal ids that contributed to a dataset"""
  contributingProposalIds: [String!]!

  """Average Fried parameter in the dataset"""
  qualityAverageFriedParameter: Float

  """Average polarimetric accuracy calculated from the dataset"""
  qualityAveragePolarimetricAccuracy: Float

  """Foreign key reference to the recipe instance that created the data set"""
  recipeInstanceId: Int!

  """
  Foreign key reference to the recipe run that created the data set.  Also used to look up provenance information
  """
  recipeRunId: Int!

  """
  Foreign key reference to the recipe specification that created the data set
  """
  recipeId: Int!

  """Time of acquisition for the earliest frame in the data set"""
  startTime: DateTime

  """
  A Boolean indicating true if all stokes parameters exist in the data set
  """
  hasAllStokes: Boolean

  """A list of which stokes parameters exist in the dataset (I, Q, U, V)"""
  stokesParameters: String

  """
  Contains the value of the OBJECT field in the input frames of the processing candidate
  """
  targetTypes: [String!]!

  """Upper bound of wavelength range within a dataset"""
  wavelengthMax: Float

  """Lower bound of wavelength range within a dataset"""
  wavelengthMin: Float

  """Status of the dataset inventory record"""
  status: String!

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean

  """Description of the experiment"""
  experimentDescription: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """Date an embargoed proposal will become unembargoed"""
  embargoEndDate: DateTime

  """Flag indicating that the dataset contains a spectral axis"""
  hasSpectralAxis: Boolean

  """Flag indicating that the dataset contains a time axis"""
  hasTemporalAxis: Boolean

  """
  A flag that indicates if the generation of this dataset required manual processing
  """
  isManuallyProcessed: Boolean

  """The average spectral sampling size if it exists (nm)"""
  averageDatasetSpectralSampling: Float

  """The average spatial sampling size if it exists"""
  averageDatasetSpatialSampling: Float

  """The average temporal sampling size if it exists"""
  averageDatasetTemporalSampling: Float

  """
  The object key used to retrieve the quality report file from the same bucket as the frame objects
  """
  qualityReportObjectKey: String

  """
  The object key used to retrieve the quality data file from the same bucket as the frame objects
  """
  qualityDataObjectKey: String

  """Id of the parameters section of the input dataset"""
  inputDatasetParametersPartId: Int

  """Id of the observe frames section of the input dataset"""
  inputDatasetObserveFramesPartId: Int

  """Id of the calibration frames section of the input dataset"""
  inputDatasetCalibrationFramesPartId: Int

  """
  Version of the High Level Software (HLS) used on the summit at the time of data acquisition
  """
  highLevelSoftwareVersion: String

  """Name of the workflow used to process the data"""
  workflowName: String

  """Version of the workflow used to process the data"""
  workflowVersion: String

  """Date the data was processed"""
  headerDataUnitCreationDate: DateTime

  """The observing program execution id the data was collected using"""
  observingProgramExecutionId: String

  """The instrument program execution id the data was collected using"""
  instrumentProgramExecutionId: String

  """
  Version of the header specification (spec 214) used to package the data
  """
  headerVersion: String

  """
  Link to the documentation for the version of the header specification (spec 214) used to package the data
  """
  headerDocumentationUrl: String

  """Link to additional documentation for the dataset"""
  infoUrl: String

  """
  Link to the documentation for the version of the workflow used to process the data
  """
  calibrationDocumentationUrl: String

  """A list of proposal investigator ids for this dataset"""
  proposalInvestigators: [String!]!

  """A list of authorized agent ids"""
  authorizedAgents: [String!]

  """Counts of frame HEALTH values. {GOOD: 32, BAD, ILL, UNKNOWN}"""
  health: HealthCounts

  """
  Counts of frame GOS_STATUS values. {open: 32, opening, closed, closing, undefined}
  """
  gosStatus: GosStatusCounts

  """Count of frames with AO_LOCK=true"""
  aoLocked: Int

  """Distribution of LIGHTLVL among frames: {min, p25, med, p75, max}"""
  lightLevel: DistributionString

  """Distribution of POL_SENS among frames: {min, p25, med, p75, max}"""
  polarimetricAccuracy: DistributionString

  """Distribution of ATMOS_R0 among frames: {min, p25, med, p75, max}"""
  friedParameter: DistributionString

  """A list of named spectral lines within a dataset"""
  spectralLines: [String!]
}

"""Data Types associated with DatasetInventoryLookup"""
enum DataType {
  DATE
  FLOAT
  STRING
  INT
}

"""Date with time (isoformat)"""
scalar DateTime

input DeadLetteredMessageByQueueRequest {
  """The queue the message was dead lettered from"""
  queue: String
}

input DeadLetteredMessageRequest {
  """Unique id for the Dead Lettered Message"""
  deadLetteredMessageId: Int

  """The queue the message was dead lettered from"""
  queue: String

  """The conversation id from the  dead lettered message"""
  conversationId: String

  """Date time in UTC the record was created"""
  createDateMin: DateTime

  """Date time in UTC the record was created"""
  createDateMax: DateTime

  """
  The number of rows to return in a single call. Default is 1000 records per page.
  """
  pageSize: Int = null

  """
  The page number to return. e.g. 1 is the first page and 10 the 10th. Default is page 1.
  """
  pageNumber: Int = null

  """
  The column to sort the results by. e.g queue to order by queue ascending or
  -queue to order by queue descending. Default is dead_lettered_message_id.
  """
  sortColumn: String = null
}

"""List of dead letter messages to act upon before removal"""
type DeadLetteredMessageResponse {
  """Unique id for the Dead Lettered Message"""
  deadLetteredMessageId: Int!

  """Properties from the dead lettered message"""
  properties: JSONString

  """The payload of the dead lettered message"""
  payload: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """The queue the message was dead lettered from"""
  queue: String

  """The conversation id from the  dead lettered message"""
  conversationId: String
}

"""Aggregation of dead letter messages by queue name"""
type DeadLetteredMessagesByQueueViewResponse {
  """The queue the message was dead lettered from"""
  queue: String!

  """Number of dead lettered messages"""
  count: Int!

  """Dead lettered messages for the queue aggregation"""
  deadLetteredMessages: [DeadLetteredMessageResponse!]
}

"""Delayed Response"""
type DelayedResponse {
  """Number of seconds the response was delayed"""
  delayDuration: Int!
}

input DelayRequest {
  """Number of seconds to delay the response"""
  delayDuration: Int = 0
}

input DeleteAuthorizedAgentRequest {
  """The primary key of the authorized agent"""
  authorizedAgentId: Int!
}

input DeleteDatasetInventoryOverrideRequest {
  """The unique dataset id of the dataset being overridden"""
  datasetId: String!
}

input DeleteDeadLetteredMessageRequest {
  """
  A list of dead lettered message ids to delete.  Elements: 'Unique id for the Dead Lettered Message'
  """
  deadLetteredMessageIds: [Int!]!
}

input DeleteDigestNotificationRequest {
  """
  A list of digest notification ids to delete.  Elements: 'Unique id of the digest notification record'
  """
  digestNotificationIds: [Int!]!
}

input DeleteExperimentDescriptionRequest {
  """The primary key for the experiment description record"""
  experimentDescriptionId: Int!
}

input DeleteFrameInventory {
  """Primary key for the frame inventory record"""
  inventoryId: String!
}

input DeleteInputDatasetInputDatasetPartRequest {
  """Unique identifier for the input dataset input dataset part"""
  inputDatasetInputDatasetPartId: Int!
}

input DeleteObjectInventory {
  """Unique id for the object inventory record"""
  inventoryId: String!
}

input DeleteProposalInvestigatorRequest {
  """The primary key for the proposal_investigator record"""
  proposalInvestigatorId: Int!
}

input DeleteRecipeInstrumentRequest {
  """Unique id of the relationship between instrument and recipe"""
  recipeInstrumentId: Int!
}

input DeleteRecipeParameterRequest {
  """Unique id for the recipe parameter  relationship"""
  recipeParameterId: Int!
}

"""Response to delete request"""
type DeleteResponse {
  """Result of delete request"""
  result: String!
}

input DigestNotificationRequest {
  """Unique id of the digest notification record"""
  digestNotificationId: Int

  """Grouping type of notification"""
  notificationType: String

  """The conversation id from the message that caused the record insertion"""
  conversationId: String
}

"""List of notifications awaiting digest processing"""
type DigestNotificationResponse {
  """Unique id of the digest notification record"""
  digestNotificationId: Int!

  """Unique id of the digest notification record"""
  notificationType: String!

  """Unique id of the digest notification record"""
  payload: JSONString

  """Unique id of the digest notification record"""
  createDate: DateTime!

  """Unique id of the digest notification record"""
  conversationId: String
}

"""A dict of float values with exactly 5 keys: min, p25, med, p75, max"""
scalar Distribution

"""A dict of float values with exactly 5 keys: min, p25, med, p75, max"""
scalar DistributionString

"""List of Experiment Ids and their associated descriptions"""
type ExperimentDescriptionResponse {
  """The primary key for the experiment description record"""
  experimentDescriptionId: Int!

  """Description of the experiment"""
  experimentDescription: String

  """Experiment Id to which the description belongs"""
  experimentId: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input ExperimentDescriptionsRequest {
  """The primary key for the experiment description record"""
  experimentDescriptionId: Int

  """Experiment Id to which the description belongs"""
  experimentId: String
}

"""Statistical information about the group of frames"""
type FrameAggregationResponse {
  """Number of frames in the set"""
  frameCount: Int

  """Sum of the frameSize of frames in the set"""
  frameSizeSum: Float

  """Bucketed proposal id counts"""
  proposalIdAggregations: [FrameSubAggregationResponse!]

  """Bucketed instrument counts"""
  instrumentAggregations: [FrameSubAggregationResponse!]

  """Bucketed instrument program execution id counts"""
  instrumentProgramExecutionIdAggregations: [FrameSubAggregationResponse!]

  """Bucketed instrument program task type counts"""
  instrumentProgramTaskTypeAggregations: [FrameSubAggregationResponse!]

  """Bucketed DSP id counts"""
  datasetParametersIdAggregations: [FrameSubAggregationResponse!]

  """Bucketed DSP sequence number counts"""
  datasetSequenceNumberAggregations: [FrameSubAggregationResponse!]

  """Bucketed wavelength counts"""
  wavelengthAggregations: [FrameSubAggregationResponse!]

  """Bucketed vbi processed flag counts"""
  vbiProcessedAggregations: [FrameSubAggregationResponse!]

  """Bucketed vbi step counts"""
  vbiNumberOfSpatialStepsAggregations: [FrameSubAggregationResponse!]

  """Bucketed visp polarimeter mode counts"""
  vispPolarimeterModeAggregations: [FrameSubAggregationResponse!]

  """Bucketed cryo-nirsp ARM counts"""
  cryonirspArmAggregations: [FrameSubAggregationResponse!]

  """Bucketed cryo-nirsp modulator state counts"""
  cryonirspModulatorStatesAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp ARM counts"""
  dlnirspArmAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp polarimeter mode counts"""
  dlnirspPolarimeterModeAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp ifu counts"""
  dlnirspIfuAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp wavelength counts"""
  dlnirspWavelengthAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp dithering mode counts"""
  dlnirspDitheringModeAggregations: [FrameSubAggregationResponse!]

  """Bucketed accumulations in frame counts"""
  accumulationsInFrameAggregations: [FrameSubAggregationResponse!]

  """Bucketed frame exposure time counts"""
  frameExposureTimeAggregations: [FrameSubAggregationResponse!]

  """Aggregation parameters propagated to sub aggregations"""
  aggregationParams: JSONString!
}

"""Accumulation of the actual filtered frame counts"""
type FrameFilterActualResponse {
  """The unique id of the frame filter actual record"""
  frameFilterActualId: Int!

  """Number of frames filtered prior to ingest"""
  filteredFrameCount: Int!

  """The observing program execution the filter accounts apply to"""
  observingProgramExecutionId: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input FrameInventoriesRequest {
  """
  A list of inventory ids (string).  Elements: 'Primary key for the frame inventory record'
  """
  inventoryIds: [String!]

  """Bucket the object resides in"""
  bucket: String

  """The key to access the object in the bucket"""
  objectKey: String

  """Earliest date for 'Date the frame was observed'"""
  observationDateMin: DateTime

  """Latest date for 'Date the frame was observed'"""
  observationDateMax: DateTime

  """Earliest date for 'The date the object inventory record was created'"""
  createDateMin: DateTime

  """Latest date for 'The date the object inventory record was created'"""
  createDateMax: DateTime

  """
  Earliest date for 'The date the object inventory record was last updated'
  """
  updateDateMin: DateTime

  """
  Latest date for 'The date the object inventory record was last updated'
  """
  updateDateMax: DateTime

  """
  Earliest date for 'The date the inventoried object was discovered to be lost'
  """
  lostDateMin: DateTime

  """
  Latest date for 'The date the inventoried object was discovered to be lost'
  """
  lostDateMax: DateTime

  """Dataset id the processed frame belongs to"""
  datasetId: String

  """Frame id of the processed frame"""
  frameId: String

  """The status of the frame e.g. AVAILABLE, LOST, or REMOVED"""
  frameStatus: String

  """
  Level of data center processing for the frame e.g. RAW, L1, L1_EXTRA, L2
  """
  processingType: String

  """The recipe run iId the processed frame was produced with"""
  recipeRunId: Int

  """
  Unique ID of the proposal associated with the experiment associated with the generation of these data
  """
  proposalId: String

  """
  Unique ID of the experiment associated with the generation of these data
  """
  experimentId: String

  """
  A list of observing program execution ids (string).  Elements: 'Observing program execution id for the frame'
  """
  observingProgramExecutionIds: [String!]

  """Observing program task type for the frame"""
  observingProgramTaskType: String

  """Name of the instrument that produced the data"""
  instrument: String

  """
  Unique ID dynamically generated at he time the InstrumentProgram was submitted
  for execution. This unique ID shall contain the InstrumentProgramID (16
  characters) as base ID, a subsequent period (.), and a unique suffix
  containing of up to 17 characters, for a total of up to 34 characters
  """
  instrumentProgramExecutionId: String

  """Instrument program task type for the frame"""
  instrumentProgramTaskType: String

  """
  Unique ID of the DataSetParameters used to configure the InstrumentProgram associated with these data
  """
  datasetParametersId: String

  """
  Number describing the current repetition of the DataSetParameterSequence within an InstrumentProgram
  """
  datasetSequenceNumber: Int

  """Minimum value for 'The filter wavelength of the frame data'"""
  wavelengthMin: Float

  """Maximum value for 'The filter wavelength of the frame data'"""
  wavelengthMax: Float

  """The filter wavelength of the frame data"""
  wavelength: Float

  """Flag indicating whether a VBI Frame was processed"""
  vbiProcessed: String

  """
  Number of images belonging to the scanned FieldOfView, representing the length of VBISTPAT
  """
  vbiNumberOfSpatialSteps: Int

  """Polarimeter Mode with which these data were acquired"""
  vispPolarimeterMode: String

  """Arm name id for CryoNIRSP that generates the data"""
  cryonirspArm: String

  """
  Number of CryoNIRSP modulator states (1 for intensity mode, default 8 for polarimetric mode)
  """
  cryonirspModulatorStates: Int

  """Arm name ID for DL-NIRSP that generates the data"""
  dlnirspArm: String

  """DL-NIRSP polarimeter mode with which these data were acquired"""
  dlnirspPolarimeterMode: String

  """DL-NIRSP IFU used for this observation"""
  dlnirspIfu: String

  """Central wavelength of the DL-NIRSP filter in use"""
  dlnirspWavelength: Float

  """
  Indicator of whether this DL-NIRSP data was acquired in dithering mode or not
  """
  dlnirspDitheringMode: Boolean

  """Number of raw frames that contributed to the FPA"""
  accumulationsInFrame: Int

  """
  Total duration of exposure to photons, in milliseconds, that resulted in this FPA
  """
  frameExposureTime: Float

  """
  The number of rows to return in a single call. Default is all records on 1 page.
  """
  pageSize: Int = 1000

  """
  The page number to return. e.g. 1 is the first page and 10 the 10th. Default is page 1
  """
  pageNumber: Int = 1
}

input FrameInventoryAggregationRequest {
  """Bucket the object resides in"""
  bucket: String

  """The key to access the object in the bucket"""
  objectKey: String

  """Earliest date for 'Date the frame was observed'"""
  observationDateMin: DateTime

  """Latest date for 'Date the frame was observed'"""
  observationDateMax: DateTime

  """Earliest date for 'The date the object inventory record was created'"""
  createDateMin: DateTime

  """Latest date for 'The date the object inventory record was created'"""
  createDateMax: DateTime

  """
  Earliest date for 'The date the object inventory record was last updated'
  """
  updateDateMin: DateTime

  """
  Latest date for 'The date the object inventory record was last updated'
  """
  updateDateMax: DateTime

  """
  Earliest date for 'The date the inventoried object was discovered to be lost'
  """
  lostDateMin: DateTime

  """
  Latest date for 'The date the inventoried object was discovered to be lost'
  """
  lostDateMax: DateTime

  """Dataset id the processed frame belongs to"""
  datasetId: String

  """Frame id of the processed frame"""
  frameId: String

  """The status of the frame e.g. AVAILABLE, LOST, or REMOVED"""
  frameStatus: String

  """
  Level of data center processing for the frame e.g. RAW, L1, L1_EXTRA, L2
  """
  processingType: String

  """The recipe run iId the processed frame was produced with"""
  recipeRunId: Int

  """
  Unique ID of the proposal associated with the experiment associated with the generation of these data
  """
  proposalId: String

  """
  Unique ID of the experiment associated with the generation of these data
  """
  experimentId: String

  """
  A list of observing program execution ids (string).  Elements: 'Observing program execution id for the frame'
  """
  observingProgramExecutionIds: [String!]

  """Observing program task type for the frame"""
  observingProgramTaskType: String

  """Name of the instrument that produced the data"""
  instrument: String

  """
  Unique ID dynamically generated at he time the InstrumentProgram was submitted
  for execution. This unique ID shall contain the InstrumentProgramID (16
  characters) as base ID, a subsequent period (.), and a unique suffix
  containing of up to 17 characters, for a total of up to 34 characters
  """
  instrumentProgramExecutionId: String

  """Instrument program task type for the frame"""
  instrumentProgramTaskType: String

  """
  Unique ID of the DataSetParameters used to configure the InstrumentProgram associated with these data
  """
  datasetParametersId: String

  """
  Number describing the current repetition of the DataSetParameterSequence within an InstrumentProgram
  """
  datasetSequenceNumber: Int

  """Minimum value for 'The filter wavelength of the frame data'"""
  wavelengthMin: Float

  """Maximum value for 'The filter wavelength of the frame data'"""
  wavelengthMax: Float

  """The filter wavelength of the frame data"""
  wavelength: Float

  """Flag indicating whether a VBI Frame was processed"""
  vbiProcessed: String

  """
  Number of images belonging to the scanned FieldOfView, representing the length of VBISTPAT
  """
  vbiNumberOfSpatialSteps: Int

  """Polarimeter Mode with which these data were acquired"""
  vispPolarimeterMode: String

  """Arm name id for CryoNIRSP that generates the data"""
  cryonirspArm: String

  """
  Number of CryoNIRSP modulator states (1 for intensity mode, default 8 for polarimetric mode)
  """
  cryonirspModulatorStates: Int

  """Arm name ID for DL-NIRSP that generates the data"""
  dlnirspArm: String

  """DL-NIRSP polarimeter mode with which these data were acquired"""
  dlnirspPolarimeterMode: String

  """DL-NIRSP IFU used for this observation"""
  dlnirspIfu: String

  """Central wavelength of the DL-NIRSP filter in use"""
  dlnirspWavelength: Float

  """
  Indicator of whether this DL-NIRSP data was acquired in dithering mode or not
  """
  dlnirspDitheringMode: Boolean

  """Number of raw frames that contributed to the FPA"""
  accumulationsInFrame: Int

  """
  Total duration of exposure to photons, in milliseconds, that resulted in this FPA
  """
  frameExposureTime: Float
}

"""Attributes for a frame inventory record"""
type FrameInventoryResponse {
  """Primary key for the frame inventory record"""
  inventoryId: String!

  """Bucket the object resides in"""
  bucket: String!

  """The key to access the object in the bucket"""
  objectKey: String!

  """Date the frame was observed"""
  observationDate: DateTime

  """The date the object inventory record was created"""
  createDate: DateTime!

  """The date the object inventory record was last updated"""
  updateDate: DateTime

  """The date the inventoried object was discovered to be lost"""
  lostDate: DateTime

  """The FITS HDU the header is found within."""
  headerHdu: Int

  """The status of the frame e.g. AVAILABLE, LOST, or REMOVED"""
  frameStatus: String!

  """Dataset id the processed frame belongs to"""
  datasetId: String

  """Frame id of the processed frame"""
  frameId: String!

  """Size of the frame in MB on disk"""
  frameSize: Float

  """
  Level of data center processing for the frame e.g. RAW, L1, L1_EXTRA, L2
  """
  processingType: String

  """The recipe run iId the processed frame was produced with"""
  recipeRunId: Int

  """
  Unique ID of the proposal associated with the experiment associated with the generation of these data
  """
  proposalId: String

  """
  Unique ID of the experiment associated with the generation of these data
  """
  experimentId: String

  """Observing program execution id for the frame"""
  observingProgramExecutionId: String

  """Observing program task type for the frame"""
  observingProgramTaskType: String

  """Name of the instrument that produced the data"""
  instrument: String

  """
  Unique ID dynamically generated at he time the InstrumentProgram was submitted
  for execution. This unique ID shall contain the InstrumentProgramID (16
  characters) as base ID, a subsequent period (.), and a unique suffix
  containing of up to 17 characters, for a total of up to 34 characters
  """
  instrumentProgramExecutionId: String

  """Instrument program task type for the frame"""
  instrumentProgramTaskType: String

  """
  Unique ID of the DataSetParameters used to configure the InstrumentProgram associated with these data
  """
  datasetParametersId: String

  """
  Number describing the current repetition of the DataSetParameterSequence within an InstrumentProgram
  """
  datasetSequenceNumber: Int

  """The filter wavelength of the frame data"""
  wavelength: Float

  """Flag indicating whether a VBI Frame was processed"""
  vbiProcessed: String

  """
  Number of images belonging to the scanned FieldOfView, representing the length of VBISTPAT
  """
  vbiNumberOfSpatialSteps: Int

  """Polarimeter Mode with which these data were acquired"""
  vispPolarimeterMode: String

  """Arm name id for CryoNIRSP that generates the data"""
  cryonirspArm: String

  """
  Number of CryoNIRSP modulator states (1 for intensity mode, default 8 for polarimetric mode)
  """
  cryonirspModulatorStates: Int

  """Arm name ID for DL-NIRSP that generates the data"""
  dlnirspArm: String

  """DL-NIRSP polarimeter mode with which these data were acquired"""
  dlnirspPolarimeterMode: String

  """DL-NIRSP IFU used for this observation"""
  dlnirspIfu: String

  """Central wavelength of the DL-NIRSP filter in use"""
  dlnirspWavelength: Float

  """
  Indicator of whether this DL-NIRSP data was acquired in dithering mode or not
  """
  dlnirspDitheringMode: Boolean

  """Number of raw frames that contributed to the FPA"""
  accumulationsInFrame: Int

  """
  Total duration of exposure to photons, in milliseconds, that resulted in this FPA
  """
  frameExposureTime: Float

  """JSON encoded string of the full document including extra fields"""
  jsonFrameHeaders: String
}

input FrameReceiptAccountsRequest {
  """The unique id of the frame receipt expected record"""
  frameReceiptAccountId: Int

  """The observing program execution the receipt accounts apply to"""
  observingProgramExecutionId: String

  """
  Flag indicating true if the received frame count is less than the expected frame count
  """
  isReceivedLessThanExpected: Boolean

  """
  Flag indicating true if the sum of received and filtered frame count is less than the expected frame count
  """
  isReceivedPlusFilteredLessThanExpected: Boolean
}

"""
Aggregation table for expected and actual frame receipts to be grouped by observing program execution id
"""
type FrameReceiptAccountViewResponse {
  """The unique id of the frame receipt expected record"""
  frameReceiptAccountId: Int!

  """The observing program execution the receipt accounts apply to"""
  observingProgramExecutionId: String!

  """The number of frames expected to be received"""
  expectedFrameCount: Int!

  """Number of frames received and ingested"""
  receivedFrameCount: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """
  Flag indicating true if the received frame count is less than the expected frame count
  """
  isReceivedLessThanExpected: Boolean!

  """Number of frames filtered prior to ingest"""
  filteredFrameCount: Int!

  """
  Flag indicating true if the sum of received and filtered frame count is less than the expected frame count
  """
  isReceivedPlusFilteredLessThanExpected: Boolean!

  """A list of related processing candidates."""
  processingCandidates: [ProcessingCandidateViewResponse!]

  """A list of related calibrations."""
  processingCandidateCalibrations: [ProcessingCandidateCalibrationResponse!]

  """A list of related frame receipt journal adjustments."""
  frameReceiptJournals: [FrameReceiptJournalResponse!]
}

"""Accumulation of the actual received frame counts"""
type FrameReceiptActualResponse {
  """The unique id of the frame receipt actual record"""
  frameReceiptActualId: Int!

  """The observing program execution the receipt accounts apply to"""
  observingProgramExecutionId: String!

  """Number of frames received and ingested"""
  receivedFrameCount: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

"""Manifest of the expected frame counts"""
type FrameReceiptExpectedResponse {
  """The unique id of the frame receipt expected record"""
  frameReceiptExpectedId: Int!

  """The observing program execution the receipt accounts apply to"""
  observingProgramExecutionId: String!

  """The number of frames expected to be received"""
  expectedFrameCount: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input FrameReceiptJournalRequest {
  """The unique id of the frame receipt journal record"""
  frameReceiptJournalId: Int

  """
  The observing program execution the receipt account journal entries apply to
  """
  observingProgramExecutionId: String
}

"""Journal entries for the expected frame receipt counts"""
type FrameReceiptJournalResponse {
  """The unique id of the frame receipt journal record"""
  frameReceiptJournalId: Int!

  """
  The observing program execution the receipt account journal entries apply to
  """
  observingProgramExecutionId: String!

  """The number of frames to increase the expected count by"""
  expectedCountCredit: Int

  """The number of frames to decrease the expected count by"""
  expectedCountDebit: Int

  """The description of the journal entry"""
  description: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """A list of frame receipt accounts."""
  frameReceiptAccounts: [FrameReceiptAccountViewResponse!]
}

"""Statistical information about a subset of frames"""
type FrameSubAggregationResponse {
  """Value for the bin"""
  value: String

  """Quantity of items in the value bin"""
  valueCount: Int!

  """Bucketed instrument counts"""
  instrumentAggregations: [FrameSubAggregationResponse!]

  """Bucketed proposal id counts"""
  proposalIdAggregations: [FrameSubAggregationResponse!]

  """Bucketed instrument program execution id counts"""
  instrumentProgramExecutionIdAggregations: [FrameSubAggregationResponse!]

  """Bucketed instrument program task type counts"""
  instrumentProgramTaskTypeAggregations: [FrameSubAggregationResponse!]

  """Bucketed DSP id counts"""
  datasetParametersIdAggregations: [FrameSubAggregationResponse!]

  """Bucketed DSP sequence number counts"""
  datasetSequenceNumberAggregations: [FrameSubAggregationResponse!]

  """Bucketed wavelength counts"""
  wavelengthAggregations: [FrameSubAggregationResponse!]

  """Bucketed vbi processed flag counts"""
  vbiProcessedAggregations: [FrameSubAggregationResponse!]

  """Bucketed vbi step counts"""
  vbiNumberOfSpatialStepsAggregations: [FrameSubAggregationResponse!]

  """Bucketed visp polarimeter mode counts"""
  vispPolarimeterModeAggregations: [FrameSubAggregationResponse!]

  """Bucketed cryo-nirsp ARM counts"""
  cryonirspArmAggregations: [FrameSubAggregationResponse!]

  """Bucketed cryo-nirsp modulator state counts"""
  cryonirspModulatorStatesAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp ARM counts"""
  dlnirspArmAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp polarimeter mode counts"""
  dlnirspPolarimeterModeAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp ifu counts"""
  dlnirspIfuAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp wavelength counts"""
  dlnirspWavelengthAggregations: [FrameSubAggregationResponse!]

  """Bucketed dl-nirsp dithering mode counts"""
  dlnirspDitheringModeAggregations: [FrameSubAggregationResponse!]

  """Bucketed accumulations in frame counts"""
  accumulationsInFrameAggregations: [FrameSubAggregationResponse!]

  """Bucketed frame exposure time counts"""
  frameExposureTimeAggregations: [FrameSubAggregationResponse!]

  """Aggregation parameters propagated to sub aggregations"""
  aggregationParams: JSONString!
}

input GlobusTransferRequest {
  """Primary key for the globus transfer table."""
  globusTransferId: Int

  """Globally unique uuid for this task."""
  taskId: String

  """The time the task completed."""
  completionTimeMin: DateTime

  """The time the task completed."""
  completionTimeMax: DateTime

  """Maximum number of records to return. default = 100"""
  pageSize: Int! = 100

  """Page number of results to return, starting with 1"""
  pageNumber: Int! = 1
}

"""A list of completed transfer tasks"""
type GlobusTransferResponse {
  """Primary key for the globus transfer table."""
  globusTransferId: BigInt!

  """Globally unique uuid for this task."""
  taskId: String!

  """Status of the task."""
  status: String!

  """User-defined label for the task."""
  label: String

  """The user ID of the task owner."""
  ownerId: String

  """The time the task was requested."""
  requestTime: DateTime

  """The time the task completed."""
  completionTime: DateTime

  """The source endpoint ID."""
  sourceEndpointId: String

  """The destination endpoint ID."""
  destinationEndpointId: String

  """The sync level of the task."""
  syncLevel: Int

  """Whether data encryption was enabled for the task."""
  encryptData: Boolean

  """Whether checksum verification was enabled for the task."""
  verifyChecksum: Boolean

  """Whether extra files at the destination were deleted."""
  deleteDestinationExtra: Boolean

  """Whether timestamps were preserved."""
  preserveTimestamp: Boolean

  """Whether source errors were skipped."""
  skipSourceErrors: Boolean

  """Whether the task failed on quota errors."""
  failOnQuotaErrors: Boolean

  """
  If the task was submitted via the CLI, this field will contain the original
  command line, including options, that created the task. If submitted via the
  Globus Web App or directly via the Transfer API, this will contain the string
  'API', followed by the API version, and optionally followed by a short string
  representing the client that submitted the request. The format of this field
  is subject to change and should not be relied upon.
  """
  command: String

  """Whether the task detail history was deleted."""
  historyDeleted: Boolean

  """The number of faults encountered during the task."""
  faults: BigInt

  """The total number of files in the task."""
  files: BigInt

  """The total number of directories in the task."""
  directories: BigInt

  """The number of files skipped during the task."""
  filesSkipped: BigInt

  """The number of files successfully transferred."""
  filesTransferred: BigInt

  """The total number of subtasks in the task."""
  subtasksTotal: BigInt

  """The number of subtasks that succeeded."""
  subtasksSucceeded: BigInt

  """The number of subtasks that failed."""
  subtasksFailed: BigInt

  """The number of subtasks that were canceled."""
  subtasksCanceled: BigInt

  """The number of subtasks that expired."""
  subtasksExpired: BigInt

  """The number of subtasks that were skipped due to errors."""
  subtasksSkippedErrors: BigInt

  """The total number of bytes transferred summed across all subtasks."""
  bytesTransferred: BigInt

  """Number of bytes checksummed when determining transfers (sync level 3)."""
  bytesChecksummed: BigInt

  """Bytes/second from start to completion/current time."""
  effectiveBytesPerSecond: BigInt

  """ID of the administrator who canceled the task."""
  canceledByAdmin: String

  """Message provided by the administrator on cancellation."""
  canceledByAdminMessage: String

  """The local user on the source endpoint."""
  sourceLocalUser: String

  """The local user on the destination endpoint."""
  destinationLocalUser: String

  """
  If store_base_path_info was set to true when task was submitted, the parent
  directory of the source_path (transfer) or path (delete) field for the first
  item listed in the task. Is null otherwise.
  """
  sourceBasePath: String

  """
  If store_base_path_info was set to true when a transfer task was submitted,
  the parent directory of the destination_path field for the first item listed
  in the task. Is null otherwise.
  """
  destinationBasePath: String

  """Parent paths from source paths in transfer details."""
  sourcePathParents: [String!]

  """Parent paths from destination paths in transfer details."""
  destinationPathParents: [String!]

  """Date the record was inserted into the globus transfer table."""
  createDate: DateTime
}

"""
Counts of frame GOS_STATUS values. {open: 32, opening, closed, closing, undefined}
"""
scalar GosStatusCounts

"""Counts of frame HEALTH values. {GOOD: 32, BAD, ILL, UNKNOWN}"""
scalar HealthCounts

"""
Join table for the many-to-many relationship between input datasets and their constituent parts
"""
type InputDatasetInputDatasetPartResponse {
  """Unique identifier for the input dataset input dataset part"""
  inputDatasetInputDatasetPartId: Int!

  """Foreign key to the input dataset"""
  inputDatasetId: Int!

  """Foreign key to the input dataset part"""
  inputDatasetPartId: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The linked input dataset."""
  inputDataset: InputDatasetResponse

  """The linked input dataset part."""
  inputDatasetPart: InputDatasetPartResponse
}

"""List of input dataset parts"""
type InputDatasetPartResponse {
  """Unique identifier for the input dataset part"""
  inputDatasetPartId: Int!

  """
  JSON document containing the list of frame_ids, object_ids, parameters, and parameter_values necessary for data processing
  """
  inputDatasetPartDocument: JSONString

  """Foreign key to the input dataset part type table"""
  inputDatasetPartTypeId: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The type of this input dataset part."""
  inputDatasetPartType: InputDatasetPartTypeResponse

  """Linkage from an input dataset part to its input datasets."""
  inputDatasetPartInputDatasets: [InputDatasetInputDatasetPartResponse!]
}

input InputDatasetPartsRequest {
  """Unique identifier for the input dataset part"""
  inputDatasetPartId: Int

  """Foreign key to the input dataset part type table"""
  inputDatasetPartTypeId: Int

  """
  The number of rows to return in a single call. Default is all records on 1 page.
  """
  pageSize: Int

  """
  The page number to return. e.g. 1 is the first page and 10 the 10th. Default is page 1
  """
  pageNumber: Int = 1

  """
  A column to order by the input dataset part results by e.g createDate to order
  by create date ascending or -updateDate to order by update date descending.
  """
  sortColumn: String = "createDate"
}

"""List of available types for input dataset parts"""
type InputDatasetPartTypeResponse {
  """Unique identifier for the input dataset part type"""
  inputDatasetPartTypeId: Int!

  """Unique name for the input dataset part type"""
  inputDatasetPartTypeName: String!

  """Description of the input dataset part type"""
  inputDatasetPartTypeDescription: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of input dataset parts of this type."""
  inputDatasetParts: [InputDatasetPartResponse!]
}

input InputDatasetPartTypesRequest {
  """Unique identifier for the input dataset part type"""
  inputDatasetPartTypeId: Int

  """Unique name for the input dataset part type"""
  inputDatasetPartTypeName: String
}

"""
Listing of input frames and parameter values either planned for use in a recipe
run, or used in a recipe run provenance record
"""
type InputDatasetResponse {
  """Unique identifier for the input data set"""
  inputDatasetId: Int!

  """
  A boolean value indicating whether the input dataset has been used and therefor cannot be updated
  """
  isActive: Boolean!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """Linkage from an input dataset to its input dataset parts."""
  inputDatasetInputDatasetParts: [InputDatasetInputDatasetPartResponse!]

  """A list of related recipe instances."""
  recipeInstances: [RecipeInstanceViewResponse!]

  """A list of related recipe run provenances."""
  recipeRunProvenances: [RecipeRunProvenanceResponse!]
}

input InputDatasetsRequest {
  """Unique identifier for the input data set"""
  inputDatasetId: Int

  """
  A boolean value indicating whether the input dataset has been used and therefor cannot be updated
  """
  isActive: Boolean
}

"""List of valid instruments"""
type InstrumentResponse {
  """Unique id of the instrument"""
  instrumentId: Int!

  """Name of the instrument"""
  instrumentName: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """Linkage from an instrument to its recipes."""
  instrumentRecipes: [RecipeInstrumentResponse!]
}

input InstrumentsRequest {
  """Unique id of the instrument"""
  instrumentId: Int

  """Name of the instrument"""
  instrumentName: String
}

input InventoryMetadataRequest {
  """Name of the inventory collection"""
  name: String
}

"""Metadata about the inventory data as a whole"""
type InventoryMetadataResponse {
  """Name of the inventory collection"""
  name: String!

  """Number of records in the inventory collection"""
  recordCount: Int!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf).
"""
scalar JSON

"""
The `JSONString` scalar type represents string values that can be coerced to JSON per ECMA-404
"""
scalar JSONString

input L2InversionInventoriesRequest {
  """The unique id of the inversion"""
  inversionId: String

  """The unique id of the dataset"""
  datasetIds: [String!]
}

input L2InversionInventory {
  """The unique id of the inversion"""
  inversionId: String!

  """The proposal id the observation data was collected under"""
  primaryProposalId: String!

  """The instrument program execution id the data was collected using"""
  instrumentProgramExecutionId: String!

  """The bucket the frame objects and asdf file reside in"""
  bucket: String!

  """
  The object key used to retrieve the asdf file from the same bucket as the frame objects
  """
  asdfObjectKey: String

  """The unique id of the dataset"""
  datasetIds: [String!]!

  """A list of named spectral lines within a dataset"""
  spectralLines: [String!]!
}

"""Metadata for the discovery of L2 Inversions"""
type L2InversionInventoryResponse {
  """The unique id of the inversion"""
  inversionId: String!

  """The proposal id the observation data was collected under"""
  primaryProposalId: String!

  """The instrument program execution id the data was collected using"""
  instrumentProgramExecutionId: String!

  """The bucket the frame objects and asdf file reside in"""
  bucket: String!

  """
  The object key used to retrieve the asdf file from the same bucket as the frame objects
  """
  asdfObjectKey: String

  """The unique id of the dataset"""
  datasetIds: [String!]!

  """A list of named spectral lines within a dataset"""
  spectralLines: [String!]!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

type Mutation {
  """Create a single frame inventory record"""
  createFrameInventory(createParams: CreateFrameInventoryRequest!): FrameInventoryResponse!

  """Update a single frame inventory record"""
  updateFrameInventory(updateParams: UpdateFrameInventoryRequest!): FrameInventoryResponse!

  """Delete a frame inventory record"""
  deleteFrameInventory(deleteParams: DeleteFrameInventory!): DeleteResponse!

  """Create a single object inventory record"""
  createObjectInventory(createParams: CreateObjectInventoryRequest!): ObjectInventoryResponse!

  """Update a single object inventory record"""
  updateObjectInventory(updateParams: UpdateObjectInventoryRequest!): ObjectInventoryResponse!

  """Delete an object inventory record"""
  deleteObjectInventory(deleteParams: DeleteObjectInventory!): DeleteResponse!

  """Create an expected object count for a dataset."""
  createDatasetCatalogReceiptAccount(createParams: CreateDatasetCatalogReceiptAccountRequest!): DatasetCatalogReceiptAccountResponse!

  """
  Create an expected frame count for an observing program id; The record is updated if already present
  """
  createFrameReceiptExpected(createParams: CreateFrameReceiptExpectedRequest!): FrameReceiptExpectedResponse!

  """
  Create a journal entry against the observing program execution id's frame receipt account.
  """
  createFrameReceiptJournal(createParams: CreateFrameReceiptJournalRequest!): FrameReceiptJournalResponse!

  """Create a new input data set"""
  createInputDataset(createParams: CreateInputDatasetRequest!): InputDatasetResponse!

  """Relate an input dataset to its constituent parts"""
  createInputDatasetInputDatasetPart(createParams: CreateInputDatasetInputDatasetPartRequest!): InputDatasetInputDatasetPartResponse!

  """Create an new input dataset part"""
  createInputDatasetPart(createParams: CreateInputDatasetPartRequest!): InputDatasetPartResponse!

  """Create an new input dataset part type"""
  createInputDatasetPartType(createParams: CreateInputDatasetPartTypeRequest!): InputDatasetPartTypeResponse!

  """Create a new instrument"""
  createInstrument(createParams: CreateInstrumentRequest!): InstrumentResponse!

  """Create a new parameter"""
  createParameter(createParams: CreateParameterRequest!): ParameterResponse!

  """Create a new parameter type"""
  createParameterType(createParams: CreateParameterTypeRequest!): ParameterTypeResponse!

  """Create a new parameter value"""
  createParameterValue(createParams: CreateParameterValueRequest!): ParameterValueResponse!

  """Create a new processing campaign"""
  createProcessingCampaign(createParams: CreateProcessingCampaignRequest!): ProcessingCampaignResponse!

  """Create a new processing candidate"""
  createProcessingCandidate(createParams: CreateProcessingCandidateRequest!): ProcessingCandidateResponse!

  """Create a new processing candidate calibration"""
  createProcessingCandidateCalibration(createParams: CreateProcessingCandidateCalibrationRequest!): ProcessingCandidateCalibrationResponse!

  """Create a new recipe"""
  createRecipe(createParams: CreateRecipeRequest!): RecipeResponse!

  """Create a new recipe configuration"""
  createRecipeConfiguration(createParams: CreateRecipeConfigurationRequest!): RecipeConfigurationResponse!

  """Create a new recipe instance"""
  createRecipeInstance(createParams: CreateRecipeInstanceRequest!): RecipeInstanceResponse!

  """Relate an instrument to a recipe"""
  createRecipeInstrument(createParams: CreateRecipeInstrumentRequest!): RecipeInstrumentResponse!

  """Relate a parameter to a recipe"""
  createRecipeParameter(createParams: CreateRecipeParameterRequest!): RecipeParameterResponse!

  """Create a new recipe run"""
  createRecipeRun(createParams: CreateRecipeRunRequest!): RecipeRunResponse!

  """Create a new recipe run provenance"""
  createRecipeRunProvenance(createParams: CreateRecipeRunProvenanceRequest!): RecipeRunProvenanceResponse!

  """Create a new recipe run status"""
  createRecipeRunStatus(createParams: CreateRecipeRunStatusRequest!): RecipeRunStatusResponse!

  """Create a new workflow"""
  createWorkflow(createParams: CreateWorkflowRequest!): WorkflowResponse!

  """Relate a processing candidate with its associated calibrations"""
  createDataAcquisitionSupportRecord(createParams: CreateDataAcquisitionSupportRecordRequest!): ProcessingCandidateResponse!

  """Delete the association between a parameter and a recipe"""
  deleteRecipeParameter(deleteParams: DeleteRecipeParameterRequest!): DeleteResponse!

  """Delete the association between an instrument and a recipe"""
  deleteRecipeInstrument(deleteParams: DeleteRecipeInstrumentRequest!): DeleteResponse!

  """
  Delete the association between an input dataset and an input dataset part
  """
  deleteInputDatasetInputDatasetPart(deleteParams: DeleteInputDatasetInputDatasetPartRequest!): DeleteResponse!

  """
  Update the actual count or locked status of a dataset catalog receipt account
  """
  updateDatasetCatalogReceiptAccount(updateParams: UpdateDatasetCatalogReceiptAccountRequest!): DatasetCatalogReceiptAccountResponse!

  """
  Increment the filtered frame count for an observing program execution id
  """
  updateFrameFilterActual(updateParams: UpdateFrameFilterActualRequest!): FrameFilterActualResponse!

  """
  Increment the received frame count for an observing program execution id
  """
  updateFrameReceiptActual(updateParams: UpdateFrameReceiptActualRequest!): FrameReceiptActualResponse!

  """Update the active flag for an input dataset"""
  updateInputDataset(updateParams: UpdateInputDatasetRequest!): InputDatasetResponse!

  """Update the name of an instrument"""
  updateInstrument(updateParams: UpdateInstrumentRequest!): InstrumentResponse!

  """Update the name and/or description of a parameter"""
  updateParameter(updateParams: UpdateParameterRequest!): ParameterResponse!

  """Update the name and/or description of a parameter type"""
  updateParameterType(updateParams: UpdateParameterTypeRequest!): ParameterTypeResponse!

  """Update the value and or start date of a parameter value"""
  updateParameterValue(updateParams: UpdateParameterValueRequest!): ParameterValueResponse!

  """
  Update the planned recipe count and/or description of a processing campaign
  """
  updateProcessingCampaign(updateParams: UpdateProcessingCampaignRequest!): ProcessingCampaignResponse!

  """
  Update the planned recipe count and/or lock flag of a processing candidate
  """
  updateProcessingCandidate(updateParams: UpdateProcessingCandidateRequest!): ProcessingCandidateResponse!

  """Update any recipe metadata"""
  updateRecipe(updateParams: UpdateRecipeRequest!): RecipeResponse!

  """Update any recipe configuration metadata"""
  updateRecipeConfiguration(updateParams: UpdateRecipeConfigurationRequest!): RecipeConfigurationResponse!

  """
  Update the recipe and/or input dataset associated with a recipe instance
  """
  updateRecipeInstance(updateParams: UpdateRecipeInstanceRequest!): RecipeInstanceResponse!

  """Update the status and/or priority of a recipe run"""
  updateRecipeRun(updateParams: UpdateRecipeRunRequest!): RecipeRunResponse!

  """
  Update the recipe run status name and/or description and/or completion flag
  """
  updateRecipeRunStatus(updateParams: UpdateRecipeRunStatusRequest!): RecipeRunStatusResponse!

  """Update the workflow name and/or description"""
  updateWorkflow(updateParams: UpdateWorkflowRequest!): WorkflowResponse!

  """Create an authorized agent record"""
  createAuthorizedAgent(createParams: CreateAuthorizedAgentRequest!): AuthorizedAgentResponse!

  """Create, or update if present, an experiment description record"""
  createExperimentDescription(createParams: CreateExperimentDescriptionRequest!): ExperimentDescriptionResponse!

  """
  Create a proposal access record and optionally associated proposal investigator records
  """
  createProposalAccess(createParams: CreateProposalAccessRequest!): ProposalAccessResponse!

  """Create a proposal investigator record"""
  createProposalInvestigator(createParams: CreateProposalInvestigatorRequest!): ProposalInvestigatorResponse!

  """Create or replace a dataset inventory record"""
  createDatasetInventory(createParams: CreateDatasetInventoryRequest!): DatasetInventoryResponse!

  """Create a dataset inventory status"""
  createDatasetInventoryStatus(createParams: CreateDatasetInventoryStatusRequest!): DatasetInventoryStatusResponse!

  """Create or replace a dataset inventory override"""
  createDatasetInventoryOverride(createParams: CreateDatasetInventoryOverrideRequest!): DatasetInventoryOverrideResponse!

  """Create a l2 inversion inventory"""
  createL2InversionInventory(createParams: L2InversionInventory!): L2InversionInventoryResponse!

  """Update a proposal access record"""
  updateDatasetInventory(updateParams: UpdateDatasetInventoryRequest!): DatasetInventoryResponse!

  """Update the dataset inventory status description"""
  updateDatasetInventoryStatus(updateParams: UpdateDatasetInventoryStatusRequest!): DatasetInventoryStatusResponse!

  """Update a proposal access record"""
  updateProposalAccess(updateParams: UpdateProposalAccessRequest!): ProposalAccessResponse!

  """Update the proposal investigators for a proposal access record"""
  updateProposalInvestigator(updateParams: UpdateProposalInvestigatorRequest!): ProposalAccessResponse!

  """Delete an authorized agent record"""
  deleteAuthorizedAgent(deleteParams: DeleteAuthorizedAgentRequest!): DeleteResponse!

  """Delete an experiment description record"""
  deleteExperimentDescription(deleteParams: DeleteExperimentDescriptionRequest!): DeleteResponse!

  """Delete a proposal investigator record"""
  deleteProposalInvestigator(deleteParams: DeleteProposalInvestigatorRequest!): DeleteResponse!

  """Delete a dataset inventory override"""
  deleteDatasetInventoryOverride(deleteParams: DeleteDatasetInventoryOverrideRequest!): DeleteResponse!

  """Create a digest notification record"""
  createDigestNotification(createParams: CreateDigestNotificationRequest!): DigestNotificationResponse!

  """Delete one or more digest notification records"""
  deleteDigestNotification(deleteParams: DeleteDigestNotificationRequest!): DeleteResponse!

  """Create a dead lettered message record"""
  createDeadLetteredMessage(createParams: CreateDeadLetteredMessageRequest!): DeadLetteredMessageResponse!

  """Delete one or more dead lettered message records"""
  deleteDeadLetteredMessage(deleteParams: DeleteDeadLetteredMessageRequest!): DeleteResponse!

  """Create a Globus transfer record"""
  createGlobusTransfer(createParams: CreateGlobusTransferRequest!): GlobusTransferResponse!
}

input ObjectInventoriesRequest {
  """
  A list of inventory ids (string).  Elements: 'Unique id for the object inventory record'
  """
  inventoryIds: [String!]

  """Bucket the object resides in"""
  bucket: String

  """The key to access the object in the bucket"""
  objectKey: String

  """The status of the object e.g. AVAILABLE, LOST, or REMOVED"""
  objectStatus: String

  """Earliest date for 'The date the object inventory record was created'"""
  createDateMin: DateTime

  """Latest date for 'The date the object inventory record was created'"""
  createDateMax: DateTime

  """
  Earliest date for 'The date the object inventory record was last updated'
  """
  updateDateMin: DateTime

  """
  Latest date for 'The date the object inventory record was last updated'
  """
  updateDateMax: DateTime

  """
  Earliest date for 'The date the inventoried object was discovered to be lost'
  """
  lostDateMin: DateTime

  """
  Latest date for 'The date the inventoried object was discovered to be lost'
  """
  lostDateMax: DateTime

  """
  The type of object being inventoried. e.g. ASDF, MOVIE, QREPORT, QDATA, PARAMETER_VALUE or WFC
  """
  objectType: String

  """
  The id for the group to which the object belongs e.g. datasetId for ASDF, movie, and Quality Report.
  """
  groupId: String

  """
  The name of the group to which the object belongs. e.g. DATASET, OPEXEC, or PARAMETER_VALUE
  """
  groupName: String

  """
  The number of rows to return in a single call. Default is all records on 1 page.
  """
  pageSize: Int = 1000

  """
  The page number to return. e.g. 1 is the first page and 10 the 10th. Default is page 1
  """
  pageNumber: Int = 1
}

"""Attributes for an object inventory record"""
type ObjectInventoryResponse {
  """Unique id for the object inventory record"""
  inventoryId: String!

  """Bucket the object resides in"""
  bucket: String!

  """The key to access the object in the bucket"""
  objectKey: String!

  """The status of the object e.g. AVAILABLE, LOST, or REMOVED"""
  objectStatus: String!

  """The date the object inventory record was created"""
  createDate: DateTime!

  """The date the object inventory record was last updated"""
  updateDate: DateTime

  """The date the inventoried object was discovered to be lost"""
  lostDate: DateTime

  """
  The type of object being inventoried. e.g. ASDF, MOVIE, QREPORT, QDATA, PARAMETER_VALUE or WFC
  """
  objectType: String!

  """
  The id for the group to which the object belongs e.g. datasetId for ASDF, movie, and Quality Report.
  """
  groupId: String

  """
  The name of the group to which the object belongs. e.g. DATASET, OPEXEC, or PARAMETER_VALUE
  """
  groupName: String
}

"""Parameters that can be used in processing"""
type ParameterResponse {
  """Unique Id for the parameter"""
  parameterId: Int!

  """Description of the parameter"""
  parameterDescription: String

  """Name of the parameter"""
  parameterName: String!

  """Foreign key to the parameter type"""
  parameterTypeId: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of historical values for this parameter."""
  parameterValues: [ParameterValueResponse!]

  """The parameter type."""
  parameterType: ParameterTypeResponse

  """Linkage from a parameter to its recipes."""
  parameterRecipes: [RecipeParameterResponse!]
}

input ParametersRequest {
  """Unique Id for the parameter"""
  parameterId: Int

  """Name of the parameter"""
  parameterName: String

  """Foreign key to the parameter type"""
  parameterTypeId: Int
}

"""List of valid parameter types"""
type ParameterTypeResponse {
  """Unique id for the parameter type"""
  parameterTypeId: Int!

  """Name of the parameter type"""
  parameterTypeName: String!

  """Description of the parameter type"""
  parameterTypeDescription: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of parameters of this parameter type."""
  parameters: [ParameterResponse!]
}

input ParameterTypesRequest {
  """Unique id for the parameter type"""
  parameterTypeId: Int

  """Name of the parameter type"""
  parameterTypeName: String
}

"""Values for processing parameters"""
type ParameterValueResponse {
  """Unique Id for the parameter value"""
  parameterValueId: Int!

  """Foreign key to the parameter"""
  parameterId: Int!

  """A JSON structured value of the parameter."""
  parameterValue: JSONString

  """Date and time the value became effective. Used for validity"""
  parameterValueStartDate: DateTime

  """A JSON structured documentation of the provenance of a parameter value"""
  parameterValueProvenance: JSONString

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """Parameter for this parameter value."""
  parameter: ParameterResponse
}

input ParameterValuesRequest {
  """Unique Id for the parameter value"""
  parameterValueId: Int

  """Foreign key to the parameter"""
  parameterId: Int
}

"""Batch of input data designated for reprocessing"""
type ProcessingCampaignResponse {
  """Primary key for the processing campaign record"""
  processingCampaignId: Int!

  """The unique name for the processing campaign"""
  processingCampaignName: String!

  """Short description of the processing campaign"""
  processingCampaignDescription: String

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  plannedRecipeCount: Int

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input ProcessingCampaignsRequest {
  """Primary key for the processing campaign record"""
  processingCampaignId: Int

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  processingCampaignName: String

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  plannedRecipeCount: Int

  """Number of recipe instances associated with a processing campaign"""
  totalRecipeInstanceCount: Int

  """
  Number of recipe instances associated with a processing campaign that can be
  considered complete via its associated recipe run statuses
  """
  completeRecipeInstanceCount: Int

  """
  A boolean value representing whether the totalRecipeInstanceCount is less than the plannedRecipeCount
  """
  isTotalRecipeInstanceCountLessThanPlanned: Boolean

  """
  A boolean value representing whether the completeRecipeInstanceCount is less than the plannedRecipeCount
  """
  isCompleteRecipeInstanceCountLessThanPlanned: Boolean

  """
  A boolean value representing whether the planned recipe count is >0 or
  intentionally 0 (planned but there are none) vs. has yet to be evaluated (unplanned)
  """
  isUnplanned: Boolean

  """Earliest date for 'Date time in UTC the record was created'"""
  createDateMin: DateTime

  """Latest date for 'Date time in UTC the record was created'"""
  createDateMax: DateTime
}

"""A view of processing campaign metadata"""
type ProcessingCampaignViewResponse {
  """Primary key for the processing campaign record"""
  processingCampaignId: Int!

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  processingCampaignName: String!

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  processingCampaignDescription: String

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  plannedRecipeCount: Int

  """Number of recipe instances associated with a processing campaign"""
  totalRecipeInstanceCount: Int!

  """
  Number of recipe instances associated with a processing campaign that can be
  considered complete via its associated recipe run statuses
  """
  completeRecipeInstanceCount: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of related recipe instances."""
  recipeInstances: [RecipeInstanceViewResponse!]
}

"""
Observing program executions that will be used to calibrate a processing candidate
"""
type ProcessingCandidateCalibrationResponse {
  """Unique id of the processing candidate calibration record"""
  processingCandidateCalibrationId: Int!

  """
  Id of the observing program execution that will be used to calibrate the candidate
  """
  observingProgramExecutionId: String!

  """Foreign key to the processing candidate"""
  processingCandidateId: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of related frame receipt accounts."""
  frameReceiptAccounts: [FrameReceiptAccountViewResponse!]

  """The observe for this calibration."""
  processingCandidate: ProcessingCandidateViewResponse
}

input ProcessingCandidateCalibrationsRequest {
  """Unique id of the processing candidate calibration record"""
  processingCandidateCalibrationId: Int

  """Foreign key to the processing candidate"""
  processingCandidateId: Int

  """
  Id of the observing program execution that will be used to calibrate the candidate
  """
  observingProgramExecutionId: String
}

"""
Observing program execution and related metadata that will be calibrated
"""
type ProcessingCandidateResponse {
  """Unique id for the processing candidate record"""
  processingCandidateId: Int!

  """
  The maximum date of the data collected in an observing program to be used in calibration. (i.e. Observe and calibrate OPs)
  """
  dataAcquisitionCompletionDate: DateTime!

  """Id of the experiment the observing program belongs to"""
  experimentId: String!

  """Locking status of the processing candidate. """
  isLocked: Boolean!

  """Id of the observing program execution that needs to be calibrated"""
  observingProgramExecutionId: String!

  """
  The number of recipe instances expected.  Used to determine if a processing candidate is complete
  """
  plannedRecipeCount: Int

  """Id of the proposal the observing program belongs to"""
  proposalId: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input ProcessingCandidatesRequest {
  """Unique id for the processing candidate record"""
  processingCandidateId: Int

  """Id of the observing program execution that needs to be calibrated"""
  observingProgramExecutionId: String

  """Id of the experiment the observing program belongs to"""
  experimentId: String

  """Id of the proposal the observing program belongs to"""
  proposalId: String

  """Locking status of the processing candidate. """
  isLocked: Boolean

  """
  The number of recipe instances expected.  Used to determine if a processing candidate is complete
  """
  plannedRecipeCount: Int

  """Number of recipe instances associated with a processing candidate"""
  totalRecipeInstanceCount: Int

  """
  Number of recipe instances associated with a processing candidate that can be
  considered complete via its associated recipe run statuses
  """
  completeRecipeInstanceCount: Int

  """
  A boolean value representing whether the totalRecipeInstanceCount is less than the plannedRecipeCount
  """
  isTotalRecipeInstanceCountLessThanPlanned: Boolean

  """
  A boolean value representing whether the completeRecipeInstanceCount is less than the plannedRecipeCount
  """
  isCompleteRecipeInstanceCountLessThanPlanned: Boolean

  """
  A boolean value representing whether the planned recipe count is >0 or
  intentionally 0 (planned but there are none) vs. has yet to be evaluated (unplanned)
  """
  isUnplanned: Boolean

  """Earliest date for 'Date time in UTC the record was created'"""
  createDateMin: DateTime

  """Latest date for 'Date time in UTC the record was created'"""
  createDateMax: DateTime
}

"""
A view on the observing program execution and related metadata that will be
calibrated which includes recipe instance aggregations
"""
type ProcessingCandidateViewResponse {
  """Unique id for the processing candidate record"""
  processingCandidateId: Int!

  """
  The maximum date of the data collected in an observing program to be used in calibration. (i.e. Observe and calibrate OPs)
  """
  dataAcquisitionCompletionDate: DateTime!

  """Id of the experiment the observing program belongs to"""
  experimentId: String!

  """Locking status of the processing candidate. """
  isLocked: Boolean!

  """Id of the observing program execution that needs to be calibrated"""
  observingProgramExecutionId: String!

  """
  The number of recipe instances expected.  Used to determine if a processing candidate is complete
  """
  plannedRecipeCount: Int

  """Id of the proposal the observing program belongs to"""
  proposalId: String!

  """
  Number of recipe instances associated with a processing candidate that can be
  considered complete via its associated recipe run statuses
  """
  completeRecipeInstanceCount: Int!

  """Number of recipe instances associated with a processing candidate"""
  totalRecipeInstanceCount: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of related frame receipt accounts."""
  frameReceiptAccounts: [FrameReceiptAccountViewResponse!]

  """A list of related calibrations."""
  processingCandidateCalibrations: [ProcessingCandidateCalibrationResponse!]

  """A list of related recipe instances."""
  recipeInstances: [RecipeInstanceViewResponse!]
}

input ProposalAccessesRequest {
  """The primary key for the proposal access record."""
  proposalAccessId: Int

  """The proposal the access record applies to"""
  proposalId: String

  """The duration of the embargo with 0 meaning no embargo at all"""
  embargoDuration: Int

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean

  """Unique id for the access rule stored in Globus"""
  accessRuleId: String

  """Unique id for the investigator user group stored in Globus"""
  embargoGroupId: String

  """
  The minimum allowable date for the proposal to have completed: Date the proposal was completed
  """
  proposalCompletionDateMin: DateTime

  """
  The maximum allowable date for the proposal to have completed: Date the proposal was completed
  """
  proposalCompletionDateMax: DateTime

  """
  The minimum allowable date for the embargo to expire: Date an embargoed proposal will become unembargoed
  """
  embargoEndDateMin: DateTime

  """
  The maximum allowable date for the embargo to expire: Date an embargoed proposal will become unembargoed
  """
  embargoEndDateMax: DateTime
}

"""List of proposals and their embargo state"""
type ProposalAccessResponse {
  """The primary key for the proposal access record."""
  proposalAccessId: Int!

  """The proposal the access record applies to"""
  proposalId: String!

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean

  """Unique id for the access rule stored in Globus"""
  accessRuleId: String

  """Unique id for the investigator user group stored in Globus"""
  embargoGroupId: String

  """Date the proposal was completed"""
  proposalCompletionDate: DateTime

  """Date an embargoed proposal will become unembargoed"""
  embargoEndDate: DateTime

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The duration of the embargo with 0 meaning no embargo at all"""
  embargoDuration: Int!

  """Index of last investigator update"""
  investigatorSeq: Int!

  """Date of last investigator update"""
  investigatorDate: DateTime

  """A list of investigators for this proposal."""
  proposalInvestigators: [ProposalInvestigatorViewResponse!]
}

"""List of investigators associated with a proposal access record"""
type ProposalInvestigatorResponse {
  """The primary key for the proposal_investigator record"""
  proposalInvestigatorId: Int!

  """Foreign key to the proposal access table"""
  proposalAccessId: Int!

  """UUID for the identity record of the user in the Globus Auth platform"""
  userId: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input ProposalInvestigatorsRequest {
  """Foreign key to the proposal access table"""
  proposalAccessId: Int

  """The primary key for the proposal_investigator record"""
  proposalInvestigatorId: Int

  """The proposal the access record applies to"""
  proposalId: String

  """UUID for the identity record of the user in the Globus Auth platform"""
  userId: String
}

"""
List of investigators associated with a proposal access record and additional proposal information
"""
type ProposalInvestigatorViewResponse {
  """Foreign key to the proposal access table"""
  proposalAccessId: Int!

  """The primary key for the proposal_investigator record"""
  proposalInvestigatorId: Int!

  """The proposal the access record applies to"""
  proposalId: String!

  """UUID for the identity record of the user in the Globus Auth platform"""
  userId: String!

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The proposal for this proposal investigator."""
  proposalAccess: ProposalAccessResponse
}

type Query {
  """Frame Inventory records"""
  frameInventories(filterParams: FrameInventoriesRequest = null): [FrameInventoryResponse!]!

  """Object Inventory records"""
  objectInventories(filterParams: ObjectInventoriesRequest = null): [ObjectInventoryResponse!]!

  """Randomly selected available frame inventory records"""
  randomFrameInventories(filterParams: RandomFrameInventoriesRequest = null): [FrameInventoryResponse!]!

  """Randomly selected available object inventory records"""
  randomObjectInventories(filterParams: RandomObjectInventoriesRequest = null): [ObjectInventoryResponse!]!

  """Statistical information about the quantity of frame inventory records"""
  frameInventoryAggregation(filterParams: FrameInventoryAggregationRequest = null): FrameAggregationResponse!

  """Metadata regarding the inventory collection"""
  inventoryMetaData(filterParams: InventoryMetadataRequest = null): [InventoryMetadataResponse!]!

  """
  Aggregations of expected and actual processed object receipts grouped by dataset id
  """
  datasetCatalogReceiptAccounts(filterParams: DatasetCatalogReceiptAccountRequest = null): [DatasetCatalogReceiptAccountResponse!]!

  """
  Aggregations of expected and actual frame receipts grouped by observing program id
  """
  frameReceiptAccounts(filterParams: FrameReceiptAccountsRequest = null): [FrameReceiptAccountViewResponse!]!

  """Journal entries for the frame receipt accounts"""
  frameReceiptJournals(filterParams: FrameReceiptJournalRequest = null): [FrameReceiptJournalResponse!]!

  """Input value part types which categorize input dataset parts"""
  inputDatasetPartTypes(filterParams: InputDatasetPartTypesRequest = null): [InputDatasetPartTypeResponse!]!

  """Input value parts either planned for use or used in a recipe run"""
  inputDatasetParts(filterParams: InputDatasetPartsRequest = null): [InputDatasetPartResponse!]!

  """
  Input values either planned for future use or already used in a recipe run
  """
  inputDatasets(filterParams: InputDatasetsRequest = null): [InputDatasetResponse!]!

  """Valid instruments"""
  instruments(filterParams: InstrumentsRequest = null): [InstrumentResponse!]!

  """Valid parameter types"""
  parameterTypes(filterParams: ParameterTypesRequest = null): [ParameterTypeResponse!]!

  """Values for processing parameters"""
  parameterValues(filterParams: ParameterValuesRequest = null): [ParameterValueResponse!]!

  """Parameters that can be used in processing"""
  parameters(filterParams: ParametersRequest = null): [ParameterResponse!]!

  """
  Observing Programs that will be used to calibrate a processing candidate
  """
  processingCandidateCalibrations(filterParams: ProcessingCandidateCalibrationsRequest = null): [ProcessingCandidateCalibrationResponse!]!

  """Observing Program and related metadata that will be calibrated"""
  processingCandidates(filterParams: ProcessingCandidatesRequest = null): [ProcessingCandidateViewResponse!]!

  """Observing Program and related metadata that will be calibrated"""
  processingCampaigns(filterParams: ProcessingCampaignsRequest = null): [ProcessingCampaignViewResponse!]!

  """Specification of a reusable recipe configurations"""
  recipeConfigurations(filterParams: RecipeConfigurationsRequest = null): [RecipeConfigurationResponse!]!

  """Instances of a recipe with a particular set of input data"""
  recipeInstances(filterParams: RecipeInstancesRequest = null): [RecipeInstanceViewResponse!]!

  """
  A record of code, workflow, and input data version information for a recipe run referenced on all processed frames
  """
  recipeRunProvenances(filterParams: RecipeRunProvenancesRequest = null): [RecipeRunProvenanceResponse!]!

  """Valid statuses for the recipe runs"""
  recipeRunStatuses(filterParams: RecipeRunStatusesRequest = null): [RecipeRunStatusResponse!]!

  """An execution of a recipe instance"""
  recipeRuns(filterParams: RecipeRunsRequest = null): [RecipeRunViewResponse!]!

  """Discoverable specification of a workflow and related parameters"""
  recipes(filterParams: RecipesRequest = null): [RecipeResponse!]!

  """
  Catalog record for the Directed Acyclic Graphs (DAGs) that represent a processing workflow
  """
  workflows(filterParams: WorkflowsRequest = null): [WorkflowResponse!]!

  """Users who are excepted from embargo requirements"""
  authorizedAgents(filterParams: AuthorizedAgentsRequest = null): [AuthorizedAgentResponse!]!

  """Descriptions of experiments as received from Ops Tools"""
  experimentDescriptions(filterParams: ExperimentDescriptionsRequest = null): [ExperimentDescriptionResponse!]!

  """Access control state (embargo) of a proposal"""
  proposalAccesses(filterParams: ProposalAccessesRequest = null): [ProposalAccessResponse!]!

  """Investigators associated with a proposal as received from Ops Tools"""
  proposalInvestigators(filterParams: ProposalInvestigatorsRequest = null): [ProposalInvestigatorViewResponse!]!

  """
  Dataset metadata used for dataset discovery.  Separate attributes are joined
  by an and operator while arrays of values for a single attribute are joined by
  an or operator.
  """
  datasetInventories(filterParams: DatasetInventoriesRequest = null): [DatasetInventoryViewResponse!]!

  """
  Endpoint providing the total number of records that would match a query
  """
  datasetInventoriesRecordCount(filterParams: DatasetInventoryRecordCountRequest = null): DatasetInventoryRecordCountResponse!

  """
  Search dataset metadata by either dataset_id or product_id, but exclude
  INACTIVE datasets. If both are provided, product_id is ignored.
  """
  datasetInventoryHistory(filterParams: DatasetInventoryHistory!): [DatasetInventoryViewResponse!]!

  """
  Endpoint providing the total number of records excluding INACTIVE datasets.
  """
  datasetInventoryHistoryRecordCount(filterParams: DatasetInventoryHistoryRecordCountRequest!): DatasetInventoryRecordCountResponse!

  """
  Endpoint providing valid values for searching select dataset inventory fields
  """
  datasetInventoryLookups: [DatasetInventoryLookupResponse!]!

  """Valid statuses for dataset inventory records"""
  datasetInventoryStatuses(filterParams: DatasetInventoryStatusesRequest = null): [DatasetInventoryStatusResponse!]!

  """Overridden dataset inventory records"""
  datasetInventoryOverrides(filterParams: DatasetInventoryOverridesRequest = null): [DatasetInventoryOverrideResponse!]!

  """Metadata used for L2 inversion discovery"""
  l2Inversions(filterParams: L2InversionInventoriesRequest = null): [L2InversionInventoryResponse!]!

  """Digest notifications to be processed"""
  digestNotifications(filterParams: DigestNotificationRequest = null): [DigestNotificationResponse!]!

  """Dead lettered messages awaiting review"""
  deadLetteredMessages(filterParams: DeadLetteredMessageRequest = null): [DeadLetteredMessageResponse!]!

  """Aggregation of dead lettered messages by queue"""
  deadLetteredMessagesByQueue(filterParams: DeadLetteredMessageByQueueRequest = null): [DeadLetteredMessagesByQueueViewResponse!]!

  """Delayed response for system verification"""
  delay(filterParams: DelayRequest = null): DelayedResponse!

  """Completed Globus transfer tasks"""
  globusTransfers(filterParams: GlobusTransferRequest = null): [GlobusTransferResponse!]!
}

input RandomFrameInventoriesRequest {
  """The number of frame inventory records to return"""
  recordCount: Int = 1
}

input RandomObjectInventoriesRequest {
  """The number of object inventory records to return"""
  recordCount: Int = 1
}

"""Specification of a default configuration reusable across recipes"""
type RecipeConfigurationResponse {
  """Unique id of the recipe configuration record"""
  recipeConfigurationId: Int!

  """
  Name of the recipe configuration used to distinguish configuration sets
  """
  recipeConfigurationName: String!

  """Description of the recipe configuration"""
  recipeConfigurationDescription: String

  """
  A JSON structured enumeration of the default configuration available for recipes
  """
  recipeConfiguration: JSONString

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of recipes that make use of this recipe configuration."""
  recipes: [RecipeResponse!]
}

input RecipeConfigurationsRequest {
  """Unique id of the recipe configuration record"""
  recipeConfigurationId: Int

  """
  Name of the recipe configuration used to distinguish configuration sets
  """
  recipeConfigurationName: String
}

"""An instance of a recipe for a particular set of input data"""
type RecipeInstanceResponse {
  """Unique Id of the recipe instance"""
  recipeInstanceId: Int!

  """Foreign key to the related recipe"""
  recipeId: Int!

  """
  Foreign key to the present (for the one used on a dataset see
  recipeRunProvenance) input dataset used in the instance definition
  """
  inputDatasetId: Int!

  """Foreign key to the related processing candidate"""
  processingCandidateId: Int

  """Foreign key to the related processing campaign"""
  processingCampaignId: Int

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime
}

input RecipeInstancesRequest {
  """Unique Id of the recipe instance"""
  recipeInstanceId: Int

  """Foreign key to the related recipe"""
  recipeId: Int

  """Foreign key to the related processing candidate"""
  processingCandidateId: Int

  """Foreign key to the related processing campaign"""
  processingCampaignId: Int

  """
  Foreign key to the present (for the one used on a dataset see
  recipeRunProvenance) input dataset used in the instance definition
  """
  inputDatasetId: Int

  """
  Number of recipe runs associated with a recipe instance that can be considered complete
  """
  completeRecipeRunCount: Int

  """Number of recipe runs associated with a recipe instance"""
  totalRecipeRunCount: Int
}

"""
An view of the instance of a recipe for a particular set of input data including aggregations of associated recipe runs
"""
type RecipeInstanceViewResponse {
  """Unique Id of the recipe instance"""
  recipeInstanceId: Int!

  """
  Foreign key to the present (for the one used on a dataset see
  recipeRunProvenance) input dataset used in the instance definition
  """
  inputDatasetId: Int!

  """Foreign key to the related processing candidate"""
  processingCandidateId: Int

  """Foreign key to the related processing campaign"""
  processingCampaignId: Int

  """Foreign key to the related recipe"""
  recipeId: Int!

  """
  Number of recipe runs associated with a recipe instance that can be considered complete
  """
  completeRecipeRunCount: Int!

  """Number of recipe runs associated with a recipe instance"""
  totalRecipeRunCount: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The recipe for this recipe instance."""
  recipe: RecipeResponse

  """The input dataset for this recipe instance."""
  inputDataset: InputDatasetResponse

  """The processing candidate for this recipe instance."""
  processingCandidate: ProcessingCandidateViewResponse

  """The processing campaign for this recipe instance."""
  processingCampaign: ProcessingCampaignViewResponse

  """A list of recipe runs for this recipe instance."""
  recipeRuns: [RecipeRunViewResponse!]
}

"""Instruments that are valid for a particular recipe"""
type RecipeInstrumentResponse {
  """Unique id of the relationship between instrument and recipe"""
  recipeInstrumentId: Int!

  """Foreign key to instrument"""
  instrumentId: Int!

  """Foreign key to recipe"""
  recipeId: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The linked recipe."""
  recipe: RecipeResponse

  """The linked instrument."""
  instrument: InstrumentResponse
}

"""Parameters that are valid for a particular recipe"""
type RecipeParameterResponse {
  """Unique id for the recipe parameter  relationship"""
  recipeParameterId: Int!

  """Foreign key to the parameter"""
  parameterId: Int!

  """Foreign key to recipe"""
  recipeId: Int!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The linked recipe."""
  recipe: RecipeResponse

  """The linked parameter."""
  parameter: ParameterResponse
}

"""Discoverable specification of a workflow and parameters"""
type RecipeResponse {
  """Unique id of the recipe"""
  recipeId: Int!

  """Name describing the recipe"""
  recipeName: String!

  """Longer description of the recipe"""
  recipeDescription: String

  """Flag indicating whether the recipe is active"""
  isActive: Boolean

  """
  Flag indicating whether the recipe will be scheduled for automatic processing or manual processing
  """
  isAutoProcessed: Boolean

  """
  Name of the resource pool which can be used as a parameter for automated processing
  """
  resourcePool: String

  """Foreign key to the workflow associated with the recipe"""
  workflowId: Int

  """Foreign key to the recipe configuration associated with the recipe"""
  recipeConfigurationId: Int

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The workflow for this recipe."""
  workflow: WorkflowResponse

  """The recipe configuration for this recipe."""
  recipeConfiguration: RecipeConfigurationResponse

  """Linkage from a recipe to its instruments."""
  recipeInstruments: [RecipeInstrumentResponse!]

  """Linkage from a recipe to its parameters."""
  recipeParameters: [RecipeParameterResponse!]

  """A list of recipe instances for this recipe."""
  recipeInstances: [RecipeInstanceViewResponse!]
}

"""
A record of code, workflow, and input data version information for a recipe run referenced on all processed frames
"""
type RecipeRunProvenanceResponse {
  """Unique id for the recipe run provenance record"""
  recipeRunProvenanceId: Int!

  """version of the code executed in a recipe run task"""
  codeVersion: String

  """Foreign key to the input dataset that was used in the recipe run"""
  inputDatasetId: Int!

  """Flag indicating whether the tag was manually intervened with"""
  isTaskManual: Boolean!

  """
  versions of the critical (as determined by the code) libraries used by the recipe run task
  """
  libraryVersions: String

  """
  Foreign key to the recipe run the provenance record applies to.  Also used to find frames the provenance record applies to
  """
  recipeRunId: Int!

  """Workflow task the provenance record applies to"""
  taskName: String

  """version of the workflow the recipe run used"""
  workflowVersion: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """The recipe run."""
  recipeRun: RecipeRunViewResponse

  """The input dataset."""
  inputDataset: InputDatasetResponse
}

input RecipeRunProvenancesRequest {
  """Unique id for the recipe run provenance record"""
  recipeRunProvenanceId: Int

  """version of the code executed in a recipe run task"""
  codeVersion: String

  """version of the workflow the recipe run used"""
  workflowVersion: String

  """Workflow task the provenance record applies to"""
  taskName: String

  """
  Foreign key to the recipe run the provenance record applies to.  Also used to find frames the provenance record applies to
  """
  recipeRunId: Int

  """Flag indicating whether the tag was manually intervened with"""
  isTaskManual: Boolean

  """Foreign key to the input dataset that was used in the recipe run"""
  inputDatasetId: Int
}

"""An execution of a recipe instance"""
type RecipeRunResponse {
  """Unique Id for the recipe run"""
  recipeRunId: Int!

  """
  Priority of the recipe run that is passed to the automated processing
  scheduler as a parameter for scheduling where a higher number equals a higher priority
  """
  priority: Int

  """Foreign Key to the recipe instance"""
  recipeInstanceId: Int!

  """Foreign Key to the recipe run status"""
  recipeRunStatusId: Int!

  """Date applicable to the recipe run status"""
  statusDate: DateTime!

  """
  The id of the airflow run used to discover the recipe run in the case of DAG failure
  """
  dagRunId: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A JSON structured enumeration of the configuration for the recipe run"""
  configuration: JSONString
}

input RecipeRunsRequest {
  """Unique Id for the recipe run"""
  recipeRunId: Int

  """Foreign Key to the recipe instance"""
  recipeInstanceId: Int

  """Foreign Key to the recipe run status"""
  recipeRunStatusId: Int

  """Name of the status"""
  recipeRunStatusName: String

  """
  Priority of the recipe run that is passed to the automated processing
  scheduler as a parameter for scheduling where a higher number equals a higher priority
  """
  priority: Int

  """
  A boolean indicator of whether a status can be interpreted as complete i.e. there is no work left to be done
  """
  isComplete: Boolean

  """
  The id of the airflow run used to discover the recipe run in the case of DAG failure
  """
  dagRunId: String

  """
  Flag indicating whether the recipe will be scheduled for automatic processing or manual processing
  """
  isAutoProcessed: Boolean

  """
  The number of rows to return in a single call. Default is all records on 1 page.
  """
  pageSize: Int

  """
  The page number to return. e.g. 1 is the first page and 10 the 10th. Default is page 1
  """
  pageNumber: Int = 1

  """
  A list of columns to order by the recipe results by e.g ['-priority',
  'statusDate'] to order by create date ascending or -instrument to order by
  instrument descending.
  """
  sortColumns: [String!]
}

input RecipeRunStatusesRequest {
  """Primary key for the recipe run status table"""
  recipeRunStatusId: Int

  """Name of the status"""
  recipeRunStatusName: String

  """
  A boolean indicator of whether a status can be interpreted as complete i.e. there is no work left to be done
  """
  isComplete: Boolean
}

"""
A list of the valid statuses for a recipe run including whether the status can be considered complete
"""
type RecipeRunStatusResponse {
  """Primary key for the recipe run status table"""
  recipeRunStatusId: Int!

  """Name of the status"""
  recipeRunStatusName: String!

  """
  Description of the status, ideally including inbound and outbound transitions
  """
  recipeRunStatusDescription: String

  """
  A boolean indicator of whether a status can be interpreted as complete i.e. there is no work left to be done
  """
  isComplete: Boolean!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of recipe runs with this status."""
  recipeRuns: [RecipeRunViewResponse!]
}

"""
A view on the execution of a recipe instance which includes the recipe status completion flag
"""
type RecipeRunViewResponse {
  """Unique Id for the recipe run"""
  recipeRunId: Int!

  """
  Priority of the recipe run that is passed to the automated processing
  scheduler as a parameter for scheduling where a higher number equals a higher priority
  """
  priority: Int

  """Foreign Key to the recipe instance"""
  recipeInstanceId: Int!

  """Foreign Key to the recipe run status"""
  recipeRunStatusId: Int!

  """Date applicable to the recipe run status"""
  statusDate: DateTime!

  """
  A boolean indicator of whether a status can be interpreted as complete i.e. there is no work left to be done
  """
  isComplete: Boolean!

  """
  The id of the airflow run used to discover the recipe run in the case of DAG failure
  """
  dagRunId: String

  """Name of the status"""
  recipeRunStatusName: String!

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """
  Flag indicating whether the recipe will be scheduled for automatic processing or manual processing
  """
  isAutoProcessed: Boolean

  """A JSON structured enumeration of the configuration for the recipe run"""
  configuration: JSONString

  """The status of this recipe run."""
  recipeRunStatus: RecipeRunStatusResponse

  """The recipe instance that applies to this recipe run."""
  recipeInstance: RecipeInstanceViewResponse

  """A list of recipe run provenances for this recipe run."""
  recipeRunProvenances: [RecipeRunProvenanceResponse!]
}

input RecipesRequest {
  """Unique id of the recipe"""
  recipeId: Int

  """Name describing the recipe"""
  recipeName: String

  """
  Flag indicating whether the recipe will be scheduled for automatic processing or manual processing
  """
  isAutoProcessed: Boolean

  """Flag indicating whether the recipe is active"""
  isActive: Boolean

  """
  Name of the resource pool which can be used as a parameter for automated processing
  """
  resourcePool: String

  """Foreign key to the workflow associated with the recipe"""
  workflowId: Int

  """Foreign key to the recipe configuration associated with the recipe"""
  recipeConfigurationId: Int
}

input UpdateDatasetCatalogReceiptAccountRequest {
  """Unique id for the dataset catalog receipt account"""
  datasetCatalogReceiptAccountId: Int!

  """Boolean that increments the received object count by one if true"""
  incrementReceivedObjectCount: Boolean

  """A flag indicating whether the dataset is locked for processing"""
  isLocked: Boolean
}

input UpdateDatasetInventoryRequest {
  """The unique id of the dataset"""
  datasetId: String!

  """
  The object key used to retrieve the asdf file from the same bucket as the frame objects
  """
  asdfObjectKey: String

  """The URL for the published browse movie in Vimeo"""
  browseMovieUrl: String

  """
  A sum of the size in GB (space on disk) of the available frames within a data set in
  """
  datasetSize: Float

  """Status of the dataset inventory record"""
  status: String

  """
  Reduces the count of available frames by one if true: Number of frames currently available within a data set
  """
  decrementFrameCount: Boolean

  """
  Increases the count of available frames by one if true: Number of frames currently available within a data set
  """
  incrementFrameCount: Boolean

  """The bucket the frame objects and asdf file reside in"""
  bucket: String

  """
  The object key used to retrieve the quality report file from the same bucket as the frame objects
  """
  qualityReportObjectKey: String

  """
  The object key used to retrieve the quality data file from the same bucket as the frame objects
  """
  qualityDataObjectKey: String
}

input UpdateDatasetInventoryStatusRequest {
  """Status code of a dataset inventory record"""
  datasetInventoryStatusCode: String!

  """Short description of the status code"""
  datasetInventoryStatusDescription: String
}

input UpdateFrameFilterActualRequest {
  """The observing program execution the filter accounts apply to"""
  observingProgramExecutionId: String!
}

input UpdateFrameInventoryRequest {
  """Primary key for the frame inventory record"""
  inventoryId: String!

  """Bucket the object resides in"""
  bucket: String

  """The key to access the object in the bucket"""
  objectKey: String

  """The status of the frame e.g. AVAILABLE, LOST, or REMOVED"""
  frameStatus: String
}

input UpdateFrameReceiptActualRequest {
  """The observing program execution the receipt accounts apply to"""
  observingProgramExecutionId: String!
}

input UpdateInputDatasetRequest {
  """Unique identifier for the input data set"""
  inputDatasetId: Int!

  """
  A boolean value indicating whether the input dataset has been used and therefor cannot be updated
  """
  isActive: Boolean!
}

input UpdateInstrumentRequest {
  """Unique id of the instrument"""
  instrumentId: Int!

  """Name of the instrument"""
  instrumentName: String!
}

input UpdateObjectInventoryRequest {
  """Unique id for the object inventory record"""
  inventoryId: String!

  """Bucket the object resides in"""
  bucket: String

  """The key to access the object in the bucket"""
  objectKey: String

  """The status of the object e.g. AVAILABLE, LOST, or REMOVED"""
  objectStatus: String
}

input UpdateParameterRequest {
  """Unique Id for the parameter"""
  parameterId: Int!

  """Name of the parameter"""
  parameterName: String

  """Description of the parameter"""
  parameterDescription: String
}

input UpdateParameterTypeRequest {
  """Unique id for the parameter type"""
  parameterTypeId: Int!

  """Name of the parameter type"""
  parameterTypeName: String

  """Description of the parameter type"""
  parameterTypeDescription: String
}

input UpdateParameterValueRequest {
  """Unique Id for the parameter value"""
  parameterValueId: Int!

  """A JSON structured value of the parameter."""
  parameterValue: JSONString

  """Date and time the value became effective. Used for validity"""
  parameterValueStartDate: DateTime

  """A JSON structured documentation of the provenance of a parameter value"""
  parameterValueProvenance: JSONString
}

input UpdateProcessingCampaignRequest {
  """Primary key for the processing campaign record"""
  processingCampaignId: Int!

  """Short description of the processing campaign"""
  processingCampaignDescription: String

  """
  The number of recipe instances expected.  Used to determine if a processing campaign is complete
  """
  plannedRecipeCount: Int
}

input UpdateProcessingCandidateRequest {
  """Unique id for the processing candidate record"""
  processingCandidateId: Int!

  """Locking status of the processing candidate. """
  isLocked: Boolean

  """
  The number of recipe instances expected.  Used to determine if a processing candidate is complete
  """
  plannedRecipeCount: Int
}

input UpdateProposalAccessRequest {
  """The primary key for the proposal access record."""
  proposalAccessId: Int!

  """Date the proposal was completed"""
  proposalCompletionDate: DateTime

  """Date an embargoed proposal will become unembargoed"""
  embargoEndDate: DateTime

  """Boolean indicating whether a proposal is currently embargoed"""
  isEmbargoed: Boolean

  """Unique id for the access rule stored in Globus"""
  accessRuleId: String

  """Unique id for the investigator user group stored in Globus"""
  embargoGroupId: String
}

input UpdateProposalInvestigatorRequest {
  """The proposal the access record applies to"""
  proposalId: String!

  """List of the globus user ids for the investigators on a proposal"""
  userIds: [String!]!

  """Index of last investigator update"""
  investigatorSeq: Int!

  """Date of last investigator update"""
  investigatorDate: DateTime!
}

input UpdateRecipeConfigurationRequest {
  """Unique id of the recipe configuration record"""
  recipeConfigurationId: Int!

  """
  Name of the recipe configuration used to distinguish configuration sets
  """
  recipeConfigurationName: String

  """Description of the recipe configuration"""
  recipeConfigurationDescription: String

  """
  A JSON structured enumeration of the default configuration available for recipes
  """
  recipeConfiguration: JSONString
}

input UpdateRecipeInstanceRequest {
  """Unique Id of the recipe instance"""
  recipeInstanceId: Int!

  """Foreign key to the related recipe"""
  recipeId: Int

  """
  Foreign key to the present (for the one used on a dataset see
  recipeRunProvenance) input dataset used in the instance definition
  """
  inputDatasetId: Int
}

input UpdateRecipeRequest {
  """Unique id of the recipe"""
  recipeId: Int!

  """Name describing the recipe"""
  recipeName: String

  """Longer description of the recipe"""
  recipeDescription: String

  """Flag indicating whether the recipe is active"""
  isActive: Boolean

  """
  Flag indicating whether the recipe will be scheduled for automatic processing or manual processing
  """
  isAutoProcessed: Boolean

  """
  Name of the resource pool which can be used as a parameter for automated processing
  """
  resourcePool: String

  """Foreign key to the workflow associated with the recipe"""
  workflowId: Int

  """Unique id of the recipe configuration record"""
  recipeConfigurationId: Int
}

input UpdateRecipeRunRequest {
  """Unique Id for the recipe run"""
  recipeRunId: Int

  """
  The id of the airflow run used to discover the recipe run in the case of DAG failure
  """
  dagRunId: String

  """
  Priority of the recipe run that is passed to the automated processing
  scheduler as a parameter for scheduling where a higher number equals a higher priority
  """
  priority: Int

  """Foreign Key to the recipe run status"""
  recipeRunStatusId: Int
}

input UpdateRecipeRunStatusRequest {
  """Primary key for the recipe run status table"""
  recipeRunStatusId: Int!

  """Name of the status"""
  recipeRunStatusName: String

  """
  Description of the status, ideally including inbound and outbound transitions
  """
  recipeRunStatusDescription: String

  """
  A boolean indicator of whether a status can be interpreted as complete i.e. there is no work left to be done
  """
  isComplete: Boolean
}

input UpdateWorkflowRequest {
  """Unique id of the workflow record"""
  workflowId: Int!

  """
  Name of the workflow which corresponds to the DAG name known to the scheduler
  """
  workflowName: String

  """Description of the workflow"""
  workflowDescription: String
}

"""
Catalog record for the Directed Acyclic Graphs (DAGs) that represent a processing workflow
"""
type WorkflowResponse {
  """Unique id of the workflow record"""
  workflowId: Int!

  """
  Name of the workflow which corresponds to the DAG name known to the scheduler
  """
  workflowName: String!

  """Description of the workflow"""
  workflowDescription: String

  """Date time in UTC the record was created"""
  createDate: DateTime!

  """Date time in UTC the record was last updated"""
  updateDate: DateTime

  """A list of recipes that use this workflow."""
  recipes: [RecipeResponse!]
}

input WorkflowsRequest {
  """Unique id of the workflow record"""
  workflowId: Int

  """
  Name of the workflow which corresponds to the DAG name known to the scheduler
  """
  workflowName: String
}

